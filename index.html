<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Moon&#39;s blog | write the code, change the world.</title>

  
  <meta name="author" content="Moon">
  

  
  <meta name="description" content="Ruby\Golang">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Moon&#39;s blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Moon&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?a9ab16fc25a6e74e9e3521e7ad3782e8";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Moon&#39;s blog</a>
    </h1>
    <p class="site-description">write the code, change the world.</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/11/goim中的数据结构/"><span>goim中的数据结构</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/11/goim中的数据结构/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-11T05:35:36.000Z">
          2018-03-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>goim中数据结构的设计非常出彩，值得仔细品味。</p>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>在长连接这样的场景下，有N条连接需要维护心跳信息，凡人的做法可能就是开启N个gorutine，但goim使用最小堆高效处理了这个问题。</p>
<p>Timer就是定时器的结构，对外提供Add、Del、Set三个方法用于添加，删除、修改TimerData。</p>
<p>TimerData存储单个定时器的信息，到期则执行回调函数fn。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libs/time/timer.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock   sync.Mutex</span><br><span class="line">	free   *TimerData</span><br><span class="line">	timers []*TimerData</span><br><span class="line">	signal *itime.Timer</span><br><span class="line">	num    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TimerData <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key    <span class="keyword">string</span></span><br><span class="line">	expire itime.Time</span><br><span class="line">	fn     <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	<span class="title">index</span>  <span class="title">int</span></span></span><br><span class="line"><span class="function">	<span class="title">next</span>   *<span class="title">TimerData</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>先看一下添加删除timer的逻辑</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libs/time/timer.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">Add</span><span class="params">(expire itime.Duration, fn <span class="keyword">func</span>()</span>) <span class="params">(td *TimerData)</span></span> &#123;</span><br><span class="line">	t.lock.Lock()</span><br><span class="line">	td = t.get()</span><br><span class="line">	td.expire = itime.Now().Add(expire)</span><br><span class="line">	td.fn = fn</span><br><span class="line">	t.add(td)</span><br><span class="line">	t.lock.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">Del</span><span class="params">(td *TimerData)</span></span> &#123;</span><br><span class="line">	t.lock.Lock()</span><br><span class="line">	t.del(td)</span><br><span class="line">	t.put(td)</span><br><span class="line">	t.lock.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">Set</span><span class="params">(td *TimerData, expire itime.Duration)</span></span> &#123;</span><br><span class="line">	t.lock.Lock()</span><br><span class="line">	t.del(td)</span><br><span class="line">	td.expire = itime.Now().Add(expire)</span><br><span class="line">	t.add(td)</span><br><span class="line">	t.lock.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除去加锁部分，内部就是调用了add、、del、get、put这几个方法。</p>
<p>get和put非常简单，只是根据当前的free指针获得或者放回去一个TimerData。</p>
<p>add和del是典型的堆操作，就是往timers这个堆里添加删除元素。</p>
<p>Timer在初始化时就会构造好一条free链表，在Add时，先取出free指向的节点，加入到timers堆中。在Del时，先从堆中删除，再放回链表中。</p>
<p>这条free链表是为了避免频繁申请内存做的优化！get和put负责在链表中申请和释放节点，add和del在获取到节点(TimerData)后进行堆的调整！</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libs/time/timer.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get get a free timer data.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">get</span><span class="params">()</span> <span class="params">(td *TimerData)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> td = t.free; td == <span class="literal">nil</span> &#123;</span><br><span class="line">		t.grow()</span><br><span class="line">		td = t.free</span><br><span class="line">	&#125;</span><br><span class="line">	t.free = td.next</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// put put back a timer data.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">put</span><span class="params">(td *TimerData)</span></span> &#123;</span><br><span class="line">	td.fn = <span class="literal">nil</span></span><br><span class="line">	td.next = t.free</span><br><span class="line">	t.free = td</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push pushes the element x onto the heap. The complexity is</span></span><br><span class="line"><span class="comment">// O(log(n)) where n = h.Len().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">add</span><span class="params">(td *TimerData)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> d itime.Duration</span><br><span class="line">	td.index = <span class="built_in">len</span>(t.timers)</span><br><span class="line">	<span class="comment">// add to the minheap last node</span></span><br><span class="line">	t.timers = <span class="built_in">append</span>(t.timers, td)</span><br><span class="line">	t.up(td.index)</span><br><span class="line">	<span class="keyword">if</span> td.index == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// if first node, signal start goroutine</span></span><br><span class="line">		d = td.Delay()</span><br><span class="line">		t.signal.Reset(d)</span><br><span class="line">		<span class="keyword">if</span> Debug &#123;</span><br><span class="line">			log.Debug(<span class="string">"timer: add reset delay %d ms"</span>, <span class="keyword">int64</span>(d)/<span class="keyword">int64</span>(itime.Millisecond))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> Debug &#123;</span><br><span class="line">		log.Debug(<span class="string">"timer: push item key: %s, expire: %s, index: %d"</span>, td.Key, td.ExpireString(), td.index)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">del</span><span class="params">(td *TimerData)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		i    = td.index</span><br><span class="line">		last = <span class="built_in">len</span>(t.timers) - <span class="number">1</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt; last || t.timers[i] != td &#123;</span><br><span class="line">		<span class="comment">// already remove, usually by expire</span></span><br><span class="line">		<span class="keyword">if</span> Debug &#123;</span><br><span class="line">			log.Debug(<span class="string">"timer del i: %d, last: %d, %p"</span>, i, last, td)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> i != last &#123;</span><br><span class="line">		t.swap(i, last)</span><br><span class="line">		t.down(i, last)</span><br><span class="line">		t.up(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// remove item is the last node</span></span><br><span class="line">	t.timers[last].index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">	t.timers = t.timers[:last]</span><br><span class="line">	<span class="keyword">if</span> Debug &#123;</span><br><span class="line">		log.Debug(<span class="string">"timer: remove item key: %s, expire: %s, index: %d"</span>, td.Key, td.ExpireString(), td.index)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，timer定时这块是怎么实现的呢？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">init</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	t.signal = itime.NewTimer(infiniteDuration)</span><br><span class="line">	t.timers = <span class="built_in">make</span>([]*TimerData, <span class="number">0</span>, num)</span><br><span class="line">	t.num = num</span><br><span class="line">	t.grow()</span><br><span class="line">	<span class="keyword">go</span> t.start() <span class="comment">// 此处开始轮询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，只启动了一个gorutine来管理所有的timer,start内部是一个无限循环，expire()负责设置一个最近的定期器，然后阻塞等待即可。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		t.expire()</span><br><span class="line">		&lt;-t.signal.C</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">expire</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		<span class="title">td</span> *<span class="title">TimerData</span></span></span><br><span class="line"><span class="function">		<span class="title">d</span>  <span class="title">itime</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function">	)</span></span><br><span class="line"><span class="function">	<span class="title">t</span>.<span class="title">lock</span>.<span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	<span class="title">for</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(t.timers) == <span class="number">0</span> &#123; <span class="comment">// 没有定时器，无限睡眠</span></span><br><span class="line">			d = infiniteDuration</span><br><span class="line">			<span class="keyword">if</span> Debug &#123;</span><br><span class="line">				log.Debug(<span class="string">"timer: no other instance"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		td = t.timers[<span class="number">0</span>] <span class="comment">// 取第一个元素，如何还没到期就根据剩余时间重置定时器</span></span><br><span class="line">		<span class="keyword">if</span> d = td.Delay(); d &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fn = td.fn</span><br><span class="line">		<span class="comment">// let caller put back, usually by Del()</span></span><br><span class="line">		t.del(td) <span class="comment">// 从堆中删除</span></span><br><span class="line">		t.lock.Unlock()</span><br><span class="line">		<span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Warn(<span class="string">"expire timer no fn"</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> Debug &#123;</span><br><span class="line">				log.Debug(<span class="string">"timer key: %s, expire: %s, index: %d expired, call fn"</span>, td.Key, td.ExpireString(), td.index)</span><br><span class="line">			&#125;</span><br><span class="line">			fn() <span class="comment">// 执行回调</span></span><br><span class="line">		&#125;</span><br><span class="line">		t.lock.Lock()</span><br><span class="line">	&#125;</span><br><span class="line">	t.signal.Reset(d)</span><br><span class="line">	<span class="keyword">if</span> Debug &#123;</span><br><span class="line">		log.Debug(<span class="string">"timer: expire reset delay %d ms"</span>, <span class="keyword">int64</span>(d)/<span class="keyword">int64</span>(itime.Millisecond))</span><br><span class="line">	&#125;</span><br><span class="line">	t.lock.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h3><p>Pool可以理解成内存，free是空闲内存的指针，Buffer是内存分配的基本单元<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock sync.Mutex</span><br><span class="line">	free *Buffer</span><br><span class="line">	max  <span class="keyword">int</span></span><br><span class="line">	num  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Buffer <span class="keyword">struct</span> &#123;</span><br><span class="line">	buf  []<span class="keyword">byte</span></span><br><span class="line">	next *Buffer <span class="comment">// next free buffer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Pool初始化时，会申请一块很大的buf，然后构建Buffer链表，每个Buffer都通过slice指向这个buf的一部分。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">grow</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		i   <span class="keyword">int</span></span><br><span class="line">		b   *Buffer</span><br><span class="line">		bs  []Buffer</span><br><span class="line">		buf []<span class="keyword">byte</span></span><br><span class="line">	)</span><br><span class="line">	buf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, p.max)</span><br><span class="line">	bs = <span class="built_in">make</span>([]Buffer, p.num)</span><br><span class="line">	p.free = &amp;bs[<span class="number">0</span>]</span><br><span class="line">	b = p.free</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>; i &lt; p.num; i++ &#123;</span><br><span class="line">		b.buf = buf[(i<span class="number">-1</span>)*p.size : i*p.size]</span><br><span class="line">		b.next = &amp;bs[i]</span><br><span class="line">		b = b.next</span><br><span class="line">	&#125;</span><br><span class="line">	b.buf = buf[(i<span class="number">-1</span>)*p.size : i*p.size]</span><br><span class="line">	b.next = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，申请和释放Buffer只需要操作链表的指针即可，复杂度O（1）</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get get a free memory buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(b *Buffer)</span></span> &#123;</span><br><span class="line">	p.lock.Lock()</span><br><span class="line">	<span class="keyword">if</span> b = p.free; b == <span class="literal">nil</span> &#123;</span><br><span class="line">		p.grow()</span><br><span class="line">		b = p.free</span><br><span class="line">	&#125;</span><br><span class="line">	p.free = b.next</span><br><span class="line">	p.lock.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Put put back a memory buffer to free.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(b *Buffer)</span></span> &#123;</span><br><span class="line">	p.lock.Lock()</span><br><span class="line">	b.next = p.free</span><br><span class="line">	p.free = b</span><br><span class="line">	p.lock.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Router模块中的Cleaner"><a href="#Router模块中的Cleaner" class="headerlink" title="Router模块中的Cleaner"></a>Router模块中的Cleaner</h3><p>Cleaner中主要使用了一条双向循环链表，但额外设计了一个map，来提供快速的节点定位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">type CleanData struct &#123;</span><br><span class="line">	Key        int64</span><br><span class="line">	expireTime time.Time</span><br><span class="line">	next, prev *CleanData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Cleaner struct &#123;</span><br><span class="line">	cLock sync.Mutex</span><br><span class="line">	size  int</span><br><span class="line">	root  CleanData</span><br><span class="line">	maps  map[int64]*CleanData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Cleaner) PushFront(key int64, expire time.Duration) &#123;</span><br><span class="line">	c.cLock.Lock()</span><br><span class="line">	if e, ok := c.maps[key]; ok &#123;</span><br><span class="line">		// update time</span><br><span class="line">		e.expireTime = time.Now().Add(expire)</span><br><span class="line">		c.moveToFront(e)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		e = new(CleanData)</span><br><span class="line">		e.Key = key</span><br><span class="line">		e.expireTime = time.Now().Add(expire)</span><br><span class="line">		c.maps[key] = e</span><br><span class="line">		at := &amp;c.root</span><br><span class="line">		n := at.next</span><br><span class="line">		at.next = e</span><br><span class="line">		e.prev = at</span><br><span class="line">		e.next = n</span><br><span class="line">		n.prev = e</span><br><span class="line">		c.size++</span><br><span class="line">	&#125;</span><br><span class="line">	c.cLock.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Comet模块中的RingBuf"><a href="#Comet模块中的RingBuf" class="headerlink" title="Comet模块中的RingBuf"></a>Comet模块中的RingBuf</h3><p>RingBuf是一个环形缓冲区，其中保存的是空闲的proto对象，负责TCP数据的拆包封包。每个连接都会初始化自己的RingBuf。</p>
<p>值得一提的是，RingBuf使用<code>sequence &amp; （array length－1） = array index</code>这样的方式来定位元素,非常高效。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ring <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    rp   <span class="keyword">uint64</span></span><br><span class="line">    num  <span class="keyword">uint64</span></span><br><span class="line">    mask <span class="keyword">uint64</span></span><br><span class="line">    <span class="comment">// TODO split cacheline, many cpu cache line size is 64</span></span><br><span class="line">    <span class="comment">// pad [40]byte</span></span><br><span class="line">    <span class="comment">// write</span></span><br><span class="line">    wp   <span class="keyword">uint64</span></span><br><span class="line">    data []proto.Proto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRing</span><span class="params">(num <span class="keyword">int</span>)</span> *<span class="title">Ring</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">new</span>(Ring)</span><br><span class="line">    r.init(<span class="keyword">uint64</span>(num))</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Init</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    r.init(<span class="keyword">uint64</span>(num))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">init</span><span class="params">(num <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 2^N</span></span><br><span class="line">    <span class="keyword">if</span> num&amp;(num<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> num&amp;(num<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">            num &amp;= (num - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        num = num &lt;&lt; <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    r.data = <span class="built_in">make</span>([]proto.Proto, num)</span><br><span class="line">    r.num = num</span><br><span class="line">    r.mask = r.num - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(proto *proto.Proto, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.rp == r.wp &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrRingEmpty</span><br><span class="line">    &#125;</span><br><span class="line">    proto = &amp;r.data[r.rp&amp;r.mask]</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">GetAdv</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r.rp++</span><br><span class="line">    <span class="keyword">if</span> Debug &#123;</span><br><span class="line">        log.Debug(<span class="string">"ring rp: %d, idx: %d"</span>, r.rp, r.rp&amp;r.mask)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Set</span><span class="params">()</span> <span class="params">(proto *proto.Proto, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.wp-r.rp &gt;= r.num &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrRingFull</span><br><span class="line">    &#125;</span><br><span class="line">    proto = &amp;r.data[r.wp&amp;r.mask]</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">SetAdv</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r.wp++</span><br><span class="line">    <span class="keyword">if</span> Debug &#123;</span><br><span class="line">        log.Debug(<span class="string">"ring wp: %d, idx: %d"</span>, r.wp, r.wp&amp;r.mask)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r.rp = <span class="number">0</span></span><br><span class="line">    r.wp = <span class="number">0</span></span><br><span class="line">    <span class="comment">// prevent pad compiler optimization</span></span><br><span class="line">    <span class="comment">// r.pad = [40]byte&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://ifeve.com/dissecting-disruptor-whats-so-special/" target="_blank" rel="noopener">http://ifeve.com/dissecting-disruptor-whats-so-special/</a><br><a href="https://github.com/Terry-Mao/goim" target="_blank" rel="noopener">https://github.com/Terry-Mao/goim</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/goim源码分析/">goim源码分析</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/03/11/goim中的数据结构/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/09/goim-comet模块源码分析/"><span>goim-comet模块源码分析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/09/goim-comet模块源码分析/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-09T02:04:31.000Z">
          2018-03-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>comet是客户端直接连接的节点，设计上是无状态的。通过rpc与logic服务交互，对外提供TCP、HTTP、WebSocket连接方式，自己也作为push这个rpc服务的提供方</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.go</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := InitLogicRpc(Conf.LogicAddrs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Warn(<span class="string">"logic rpc current can't connect, retry"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// start monitor</span></span><br><span class="line">    <span class="keyword">if</span> Conf.MonitorOpen &#123;</span><br><span class="line">        InitMonitor(Conf.MonitorAddrs)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">//bucket round server的初始化，下面会讲</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// white list</span></span><br><span class="line">    <span class="comment">// tcp comet</span></span><br><span class="line">    <span class="keyword">if</span> err := InitTCP(Conf.TCPBind, Conf.MaxProc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// websocket comet</span></span><br><span class="line">    <span class="keyword">if</span> err := InitWebsocket(Conf.WebsocketBind); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// flash safe policy</span></span><br><span class="line">    <span class="keyword">if</span> Conf.FlashPolicyOpen &#123;</span><br><span class="line">        <span class="keyword">if</span> err := InitFlashPolicy(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wss comet</span></span><br><span class="line">    <span class="keyword">if</span> Conf.WebsocketTLSOpen &#123;</span><br><span class="line">        <span class="keyword">if</span> err := InitWebsocketWithTLS(Conf.WebsocketTLSBind, Conf.WebsocketCertFile, Conf.WebsocketPrivateFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// start rpc</span></span><br><span class="line">    <span class="keyword">if</span> err := InitRPCPush(Conf.RPCPushAddrs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="InitTCP"><a href="#InitTCP" class="headerlink" title="InitTCP"></a>InitTCP</h2><p>InitXXX的作用是暴露不同的服务给客户端使用，选一个看就可以了。</p>
<p>在多个gorutine中调用了AcceptTCP，充分发挥多核能力<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; accept; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> acceptTCP(DefaultServer, listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>accept之后，核心逻辑实现在serveTCP中,首先调用auth服务，获得subKey,然后把channel放进bucket里</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="keyword">if</span> p, err = ch.CliProto.Set(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> key, ch.RoomId, hb, err = server.authTCP(rr, wr, p); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        b = server.Bucket(key)</span><br><span class="line">        err = b.Put(key, ch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>serveTCP方法中，当前gorutine负责读数据，处理心跳，把数据封装成proto对象然后保存到channel的CliProto中，然后通知dispatchTCP处理<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p, err = ch.CliProto.Set(); err != <span class="literal">nil</span> &#123; <span class="comment">// 从channel中申请一个buffer用来存放proto</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> white &#123;</span><br><span class="line">            DefaultWhitelist.Log.Printf(<span class="string">"key: %s start read proto\n"</span>, key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err = p.ReadTCP(rr); err != <span class="literal">nil</span> &#123; <span class="comment">// 读proto</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> white &#123;</span><br><span class="line">            DefaultWhitelist.Log.Printf(<span class="string">"key: %s read proto:%v\n"</span>, key, p)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p.Operation == define.OP_HEARTBEAT &#123; <span class="comment">// 维持心跳</span></span><br><span class="line">            tr.Set(trd, hb)</span><br><span class="line">            p.Body = <span class="literal">nil</span></span><br><span class="line">            p.Operation = define.OP_HEARTBEAT_REPLY</span><br><span class="line">            <span class="keyword">if</span> Debug &#123;</span><br><span class="line">                log.Debug(<span class="string">"key: %s receive heartbeat"</span>, key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err = server.operator.Operate(p); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> white &#123;</span><br><span class="line">            DefaultWhitelist.Log.Printf(<span class="string">"key: %s process proto:%v\n"</span>, key, p)</span><br><span class="line">        &#125;</span><br><span class="line">        ch.CliProto.SetAdv()</span><br><span class="line">        ch.Signal() <span class="comment">//通知dispatchTCP处理</span></span><br><span class="line">        <span class="keyword">if</span> white &#123;</span><br><span class="line">            DefaultWhitelist.Log.Printf(<span class="string">"key: %s signal\n"</span>, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>dispatchTCP中，如果收到proto.ProtoReady，就表示读取到了一个proto，然后原样写回？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> proto.ProtoReady:</span><br><span class="line">    <span class="comment">// fetch message from svrbox(client send)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p, err = ch.CliProto.Get(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = <span class="literal">nil</span> <span class="comment">// must be empty error</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> white &#123;</span><br><span class="line">            DefaultWhitelist.Log.Printf(<span class="string">"key: %s start write client proto%v\n"</span>, key, p)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err = p.WriteTCP(wr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> failed</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> white &#123;</span><br><span class="line">            DefaultWhitelist.Log.Printf(<span class="string">"key: %s write client proto%v\n"</span>, key, p)</span><br><span class="line">        &#125;</span><br><span class="line">        p.Body = <span class="literal">nil</span> <span class="comment">// avoid memory leak</span></span><br><span class="line">        ch.CliProto.GetAdv()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Round"><a href="#Round" class="headerlink" title="Round"></a>Round</h3><p>goim自己进行了buffer的管理，避免了频繁申请内存的开销。通过自定义的Pool结构来分配Buffer，因为分配时要加锁，使用Round来组合多个Pool，通过mod运算随机获取一个Pool，来减缓锁的争用。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// round.go</span></span><br><span class="line"><span class="comment">// Reader get a reader memory buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Round)</span> <span class="title">Reader</span><span class="params">(rn <span class="keyword">int</span>)</span> *<span class="title">bytes</span>.<span class="title">Pool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(r.readers[rn%r.options.Reader])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer get a writer memory buffer pool.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Round)</span> <span class="title">Writer</span><span class="params">(rn <span class="keyword">int</span>)</span> *<span class="title">bytes</span>.<span class="title">Pool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(r.writers[rn%r.options.Writer])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pool内部使用一条单链表，维护一个free指针指向未分配的buffer</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libs/buffer.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">grow</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        i   <span class="keyword">int</span></span><br><span class="line">        b   *Buffer</span><br><span class="line">        bs  []Buffer</span><br><span class="line">        buf []<span class="keyword">byte</span></span><br><span class="line">    )</span><br><span class="line">    buf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, p.max) <span class="comment">// 所有的Buffer都从这里分配</span></span><br><span class="line">    bs = <span class="built_in">make</span>([]Buffer, p.num) <span class="comment">// Buffer数组</span></span><br><span class="line">    p.free = &amp;bs[<span class="number">0</span>] <span class="comment">//构造Buffer链</span></span><br><span class="line">    b = p.free</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>; i &lt; p.num; i++ &#123;</span><br><span class="line">        b.buf = buf[(i<span class="number">-1</span>)*p.size : i*p.size]</span><br><span class="line">        b.next = &amp;bs[i]</span><br><span class="line">        b = b.next</span><br><span class="line">    &#125;</span><br><span class="line">    b.buf = buf[(i<span class="number">-1</span>)*p.size : i*p.size]</span><br><span class="line">    b.next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get get a free memory buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(b *Buffer)</span></span> &#123;</span><br><span class="line">    p.lock.Lock()</span><br><span class="line">    <span class="keyword">if</span> b = p.free; b == <span class="literal">nil</span> &#123;</span><br><span class="line">        p.grow()</span><br><span class="line">        b = p.free</span><br><span class="line">    &#125;</span><br><span class="line">    p.free = b.next</span><br><span class="line">    p.lock.Unlock()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>goim的Timer也是基于堆结构改写的，内部只有一个timer，不断把定时器设置成堆顶元素的触发时间来提高效率。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>TCP连接会被封装到Channel这个结构中，使用CliProto来处理封包拆包</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Channel <span class="keyword">struct</span> &#123;</span><br><span class="line">    RoomId   <span class="keyword">int32</span></span><br><span class="line">    CliProto Ring</span><br><span class="line">    signal   <span class="keyword">chan</span> *proto.Proto</span><br><span class="line">    Writer   bufio.Writer</span><br><span class="line">    Reader   bufio.Reader</span><br><span class="line">    Next     *Channel</span><br><span class="line">    Prev     *Channel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Ring"><a href="#Ring" class="headerlink" title="Ring"></a>Ring</h4><p>Ring是Channel内部用来保存并重用proto的一个结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Ring struct &#123;</span><br><span class="line">    // read</span><br><span class="line">    rp   uint64</span><br><span class="line">    num  uint64</span><br><span class="line">    mask uint64</span><br><span class="line">    // TODO split cacheline, many cpu cache line size is 64</span><br><span class="line">    // pad [40]byte</span><br><span class="line">    // write</span><br><span class="line">    wp   uint64</span><br><span class="line">    data []proto.Proto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Bucket"><a href="#Bucket" class="headerlink" title="Bucket"></a>Bucket</h3><p>bucket是channel的容器<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.go</span></span><br><span class="line"></span><br><span class="line">    buckets := <span class="built_in">make</span>([]*Bucket, Conf.Bucket)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; Conf.Bucket; i++ &#123;</span><br><span class="line">        buckets[i] = NewBucket(BucketOptions&#123;</span><br><span class="line">            ChannelSize:   Conf.BucketChannel,</span><br><span class="line">            RoomSize:      Conf.BucketRoom,</span><br><span class="line">            RoutineAmount: Conf.RoutineAmount,</span><br><span class="line">            RoutineSize:   Conf.RoutineSize,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/goim源码分析/">goim源码分析</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/03/09/goim-comet模块源码分析/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/07/goim-router模块源码分析/"><span>goim-router模块源码分析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/07/goim-router模块源码分析/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-07T08:17:13.000Z">
          2018-03-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>这个模块是用于保存状态信息的(例如在线的session)</p>
<p>文档里是这样描述的<br>router 属于有状态节点，logic可以使用一致性hash配置节点，增加多个router节点（目前还不支持动态扩容），提前预估好在线和压力情况</p>
<p>从main.go入手</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="keyword">if</span> err := InitConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    runtime.GOMAXPROCS(Conf.MaxProc)</span><br><span class="line">    log.LoadConfiguration(Conf.Log)</span><br><span class="line">    <span class="keyword">defer</span> log.Close()</span><br><span class="line">    log.Info(<span class="string">"router[%s] start"</span>, VERSION)</span><br><span class="line">    <span class="comment">// start prof</span></span><br><span class="line">    perf.Init(Conf.PprofAddrs)</span><br><span class="line">    <span class="comment">// start monitor</span></span><br><span class="line">    <span class="keyword">if</span> Conf.MonitorOpen &#123;</span><br><span class="line">        InitMonitor(Conf.MonitorAddrs)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// start rpc</span></span><br><span class="line">    buckets := <span class="built_in">make</span>([]*Bucket, Conf.Bucket)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; Conf.Bucket; i++ &#123;</span><br><span class="line">        buckets[i] = NewBucket(Conf.Session, Conf.Server, Conf.Cleaner)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := InitRPC(buckets); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// block until a signal is received.</span></span><br><span class="line">    InitSignal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>忽略flag和config部分的处理，这里主要涉及了<strong>perf</strong>，<strong>monitor</strong>监控，主<strong>RPC</strong>逻辑,以及<strong>signal</strong>处理</p>
<h3 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h3><p>内部使用了net/http/pprof进行性能分析</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(pprofBind []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    pprofServeMux := http.NewServeMux()</span><br><span class="line">    pprofServeMux.HandleFunc(<span class="string">"/debug/pprof/"</span>, pprof.Index)</span><br><span class="line">    pprofServeMux.HandleFunc(<span class="string">"/debug/pprof/cmdline"</span>, pprof.Cmdline)</span><br><span class="line">    pprofServeMux.HandleFunc(<span class="string">"/debug/pprof/profile"</span>, pprof.Profile)</span><br><span class="line">    pprofServeMux.HandleFunc(<span class="string">"/debug/pprof/symbol"</span>, pprof.Symbol)</span><br><span class="line">    <span class="keyword">for</span> _, addr := <span class="keyword">range</span> pprofBind &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := http.ListenAndServe(addr, pprofServeMux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Error(<span class="string">"http.ListenAndServe(\"%s\", pprofServeMux) error(%v)"</span>, addr, err)</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p>是一个简单ping请求处理,一看就是用来监测服务存活状态的</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitMonitor</span><span class="params">(binds []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">new</span>(Monitor)</span><br><span class="line">    monitorServeMux := http.NewServeMux()</span><br><span class="line">    monitorServeMux.HandleFunc(<span class="string">"/monitor/ping"</span>, m.Ping)</span><br><span class="line">    <span class="keyword">for</span> _, addr := <span class="keyword">range</span> binds &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(bind <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := http.ListenAndServe(bind, monitorServeMux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Error(<span class="string">"http.ListenAndServe(\"%s\", pprofServeMux) error(%v)"</span>, addr, err)</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(addr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// monitor ping</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Monitor)</span> <span class="title">Ping</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"ok"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p>信号处理，收到SIGHUP重载配置，这是符合linux上惯用约定的</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitSignal</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    signal.Notify(c, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT, syscall.SIGSTOP)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        s := &lt;-c</span><br><span class="line">        log.Info(<span class="string">"router[%s] get a signal %s"</span>, VERSION, s.String())</span><br><span class="line">        <span class="keyword">switch</span> s &#123;</span><br><span class="line">        <span class="keyword">case</span> syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGSTOP, syscall.SIGINT:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> syscall.SIGHUP:</span><br><span class="line">            reload()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reload</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newConf, err := ReloadConfig()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Error(<span class="string">"ReloadConfig() error(%v)"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    Conf = newConf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主RPC逻辑"><a href="#主RPC逻辑" class="headerlink" title="主RPC逻辑"></a>主RPC逻辑</h2><p>这里有Session、Cleaner、Bucket这三个主要的结构</p>
<p>Bucket是Session的容器，为了减少锁争夺，会有多个Bucket，根据用户id与Bucket数量进行mod运算来确定，这个Session放到哪个Bucket中，是一种很常见的sharding</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rpc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RouterRPC)</span> <span class="title">bucket</span><span class="params">(userId <span class="keyword">int64</span>)</span> *<span class="title">Bucket</span></span> &#123;</span><br><span class="line">    idx := <span class="keyword">int</span>(userId % r.BucketIdx) <span class="comment">// mod</span></span><br><span class="line">    <span class="comment">// fix panic</span></span><br><span class="line">    <span class="keyword">if</span> idx &lt; <span class="number">0</span> &#123;</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r.Buckets[idx]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RouterRPC)</span> <span class="title">Put</span><span class="params">(arg *proto.PutArg, reply *proto.PutReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    reply.Seq = r.bucket(arg.UserId).Put(arg.UserId, arg.Server, arg.RoomId)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucket.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">Put</span><span class="params">(userId <span class="keyword">int64</span>, server <span class="keyword">int32</span>, roomId <span class="keyword">int32</span>)</span> <span class="params">(seq <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        s  *Session</span><br><span class="line">        ok <span class="keyword">bool</span></span><br><span class="line">    )</span><br><span class="line">    b.bLock.Lock() <span class="comment">//加锁，只影响这个Bucket</span></span><br><span class="line">    <span class="keyword">if</span> s, ok = b.sessions[userId]; !ok &#123;</span><br><span class="line">        s = NewSession(b.server)</span><br><span class="line">        b.sessions[userId] = s</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> roomId != define.NoRoom &#123;</span><br><span class="line">        seq = s.PutRoom(server, roomId)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        seq = s.Put(server)</span><br><span class="line">    &#125;</span><br><span class="line">    b.counter(userId, server, roomId, <span class="literal">true</span>)</span><br><span class="line">    b.bLock.Unlock()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cleaner是与Session一一对应的一个结构，用于清理Session信息,每个Bucket会有一个单独的gorutine进行定时清理</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bucket.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBucket</span><span class="params">(session, server, cleaner <span class="keyword">int</span>)</span> *<span class="title">Bucket</span></span> &#123;</span><br><span class="line">    b := <span class="built_in">new</span>(Bucket)</span><br><span class="line">    b.sessions = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]*Session, session)</span><br><span class="line">    b.roomCounter = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">int32</span>)</span><br><span class="line">    b.serverCounter = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">int32</span>)</span><br><span class="line">    b.userServerCounter = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int32</span>)</span><br><span class="line">    b.cleaner = NewCleaner(cleaner)</span><br><span class="line">    b.server = server</span><br><span class="line">    b.session = session</span><br><span class="line">    <span class="keyword">go</span> b.clean() <span class="comment">//启动清理gorutine</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">clean</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        i       <span class="keyword">int</span></span><br><span class="line">        userIds []<span class="keyword">int64</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        userIds = b.cleaner.Clean()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(userIds) != <span class="number">0</span> &#123;</span><br><span class="line">            b.bLock.Lock()</span><br><span class="line">            <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(userIds); i++ &#123;</span><br><span class="line">                b.delEmpty(userIds[i]) 从sessions <span class="keyword">map</span>中删掉对应的session</span><br><span class="line">            &#125;</span><br><span class="line">            b.bLock.Unlock()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(Conf.BucketCleanPeriod) <span class="comment">//休息一段时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cleaner本身的结构是经过精心设计的，使用了一条双向循环链表来记录当前所有Session的信息，为了克服移除一个节点时需要遍历链表，额外用了一个map来快速定位到节点，然后操作这个节点的指针来进行删除</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cleaner)</span> <span class="title">remove</span><span class="params">(key <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e, ok := c.maps[key]; ok &#123; <span class="comment">//通过map定位</span></span><br><span class="line">        <span class="built_in">delete</span>(c.maps, key) <span class="comment">// 从map中删除</span></span><br><span class="line">        <span class="comment">// 从链表中删除</span></span><br><span class="line">        e.prev.next = e.next</span><br><span class="line">        e.next.prev = e.prev</span><br><span class="line">        e.next = <span class="literal">nil</span> <span class="comment">// avoid memory leaks</span></span><br><span class="line">        e.prev = <span class="literal">nil</span> <span class="comment">// avoid memory leaks</span></span><br><span class="line">        c.size--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cleaner)</span> <span class="title">Clean</span><span class="params">()</span> <span class="params">(keys []<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        i <span class="keyword">int</span></span><br><span class="line">        e *CleanData</span><br><span class="line">    )</span><br><span class="line">    keys = <span class="built_in">make</span>([]<span class="keyword">int64</span>, <span class="number">0</span>, maxCleanNum)</span><br><span class="line">    c.cLock.Lock()</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; maxCleanNum; i++ &#123; <span class="comment">// 每次最多只清理maxCleanNum个节点，don't know why</span></span><br><span class="line">        <span class="keyword">if</span> e = c.back(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> e.expire() &#123;</span><br><span class="line">                c.remove(e.Key)</span><br><span class="line">                keys = <span class="built_in">append</span>(keys, e.Key)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// next time</span></span><br><span class="line">    c.cLock.Unlock()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个问题是，没有看懂过期的逻辑。从链表尾部开始清理，却在Del时把节点放到头部？</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/goim源码分析/">goim源码分析</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/03/07/goim-router模块源码分析/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/01/使用influxdb构建运营数据Metrics系统/"><span>使用influxdb收集用户行为数据</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/01/使用influxdb构建运营数据Metrics系统/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-01T06:25:40.000Z">
          2018-03-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>目前我们需要收集一些用户在站点上的行为数据，又不想投入精力研发一整套的体系，于是找到了influxdb。</p>
<p>influxdb内置了HTTP API,免去了编写接入代码的繁琐，并带有数据查询和展示的组件，非常适合。</p>
<p>安装过程略去不提，参考<a href="https://docs.influxdata.com/influxdb/v1.4/introduction/getting_started/" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>Influxdb</li>
<li>Chronograf</li>
<li>例子</li>
</ul>
<h2 id="Influxdb"><a href="#Influxdb" class="headerlink" title="Influxdb"></a>Influxdb</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一条influxdb的记录的结构是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;measurement&gt;[,&lt;tag-key&gt;=&lt;tag-value&gt;...] &lt;field-key&gt;=&lt;field-value&gt;[,&lt;field2-key&gt;=&lt;field2-value&gt;...] [unix-nano-timestamp]</span><br><span class="line"></span><br><span class="line">例如</span><br><span class="line"></span><br><span class="line">cpu,host=serverA,region=us_west value=0.64</span><br><span class="line">payment,device=mobile,product=Notepad,method=credit billed=33,licenses=3i 1434067467100293230</span><br><span class="line">stock,symbol=AAPL bid=127.46,ask=127.48</span><br><span class="line">temperature,machine=unit42,type=assembly external=25,internal=37 1434067467000000000</span><br></pre></td></tr></table></figure>
<p>类比于RDMBS</p>
<table>
<thead>
<tr>
<th>influxdb</th>
<th>rdbms</th>
</tr>
</thead>
<tbody>
<tr>
<td>unix-nano-timestamp</td>
<td>primary key</td>
</tr>
<tr>
<td>measurement</td>
<td>table</td>
</tr>
<tr>
<td>tag</td>
<td>indexed column</td>
</tr>
<tr>
<td>fields</td>
<td>column</td>
</tr>
</tbody>
</table>
<h3 id="HTTP-API"><a href="#HTTP-API" class="headerlink" title="HTTP API"></a>HTTP API</h3><p>influxdb的所有操作都可以通过HTTP API来完成</p>
<p><a href="https://docs.influxdata.com/influxdb/v1.4/guides/writing_data/" target="_blank" rel="noopener">写数据</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XPOST &apos;http://localhost:8086/write?db=mydb&apos; --data-binary &apos;cpu_load_short,host=server01,region=us-west value=0.64 1434055562000000000&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="Authentication-amp-Authorization"><a href="#Authentication-amp-Authorization" class="headerlink" title="Authentication &amp; Authorization"></a>Authentication &amp; Authorization</h3><p>通过HTTP API可以进行DDL操作，我们需要有一些<a href="https://docs.influxdata.com/influxdb/v1.4/query_language/authentication_and_authorization/#authorization" target="_blank" rel="noopener">权限机制</a>来保证安全.</p>
<ol>
<li>修改配置文件<strong>/etc/influxdb/influxdb.conf</strong>并重启</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[http]</span><br><span class="line">  ...</span><br><span class="line">  auth-enabled = true</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<ol>
<li>创建用户</li>
</ol>
<p>创建超级用户admin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER admin WITH PASSWORD &apos;123456&apos; WITH ALL PRIVILEGES</span><br></pre></td></tr></table></figure>
<p>创建普通用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER reader WITH PASSWORD &apos;123456&apos;</span><br><span class="line">GRANT READ ON &quot;mydb&quot; TO &quot;reader&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Rentention-Policy"><a href="#Rentention-Policy" class="headerlink" title="Rentention Policy"></a>Rentention Policy</h3><p>时序数据的量可能会非常大，需要定义保存数据的<a href="https://docs.influxdata.com/influxdb/v1.4/query_language/database_management/#retention-policy-management" target="_blank" rel="noopener">策略</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE RETENTION POLICY &quot;one_day_only&quot; ON &quot;mydb&quot; DURATION 1d REPLICATION 1 DEFAULT</span><br></pre></td></tr></table></figure>
<h2 id="Chronograf"><a href="#Chronograf" class="headerlink" title="Chronograf"></a>Chronograf</h2><p>官方有一个叫TICK的技术栈推荐，但对于我们的场景，只要结合其中的IC就可以了，即influxdb和chronograf.</p>
<p><a href="https://docs.influxdata.com/influxdb/v1.2/introduction/installation/" target="_blank" rel="noopener">安装启动过程</a>不提</p>
<p>在使用它之前，需要先学习一下基本的<a href="https://docs.influxdata.com/influxdb/v1.4/query_language/data_exploration/" target="_blank" rel="noopener">influxdb查询语法</a></p>
<p><img src="http://7xqlni.com1.z0.glb.clouddn.com/chronograf.png" alt=""></p>
<p>这样，就可以轻松的在Chronograf中查询数据了，如果需要额外的数据，可以让业务方导出csv自行分析。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/后端/">后端</a><a href="/tags/golang/">golang</a><a href="/tags/influxdb/">influxdb</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/03/01/使用influxdb构建运营数据Metrics系统/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/25/linux服务管理-upstart/"><span>linux服务管理-upstart</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/25/linux服务管理-upstart/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-25T01:48:30.000Z">
          2018-02-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><img src="https://assets.digitalocean.com/articles/upstart_event_system/1.png" alt=""><br>当我们写完一个go程序时，部署只需要把二进制包拷贝到服务器上即可。</p>
<p>但在真正的<strong>生产环境</strong>中，如果程序出于某种原因崩溃了，我们会面临两个问题</p>
<ol>
<li>如何得知程序崩溃，如果靠人工的方式，无疑是有巨大时间滞后的</li>
<li>如何方便的在崩溃后重启</li>
</ol>
<p>在Ruby的世界中，例如unicorn这样的应用服务器，会有一个master进程，专门解决以上问题，当worker崩溃时，master就会重新fork出一个worker进程。</p>
<h3 id="upstart简介"><a href="#upstart简介" class="headerlink" title="upstart简介"></a>upstart简介</h3><p>upstart是linux主流发行版(ubuntu,RHEL…)本自带的进程管理系统</p>
<p>程序开发时需要注意的事项</p>
<p>作为程序开发人员，在编写系统服务时，需要了解 upstart 的一些特殊要求。只有符合这些要求的软件才可以被 upstart 管理。</p>
<p>规则一，派生次数需声明。</p>
<p>很多 Linux 后台服务都通过派生两次的技巧将自己变成后台服务程序。如果您编写的服务也采用了这个技术，就必须通过文档或其它的某种方式明确地让 upstart 的维护人员知道这一点，这将影响 upstart 的 expect stanza，我们在前面已经详细介绍过这个 stanza 的含义。</p>
<p>规则二，派生后即可用。</p>
<p>后台程序在完成第二次派生的时候，必须保证服务已经可用。因为 upstart 通过派生计数来决定服务是否处于就绪状态。</p>
<p>规则三，遵守 SIGHUP 的要求。</p>
<p>upstart 会给守护进程发送 SIGHUP 信号，此时，upstart 希望该守护进程做以下这些响应工作：</p>
<p>•完成所有必要的重新初始化工作，比如重新读取配置文件。这是因为 upstart 的命令”initctl reload”被设计为可以让服务在不重启的情况下更新配置。</p>
<p>•守护进程必须继续使用现有的 PID，即收到 SIGHUP 时不能调用 fork。如果服务必须在这里调用 fork，则等同于派生两次，参考上面的规则一的处理。这个规则保证了 upstart 可以继续使用 PID 管理本服务。</p>
<p>规则四，收到 SIGTEM 即 shutdown。</p>
<p>•当收到 SIGTERM 信号后，upstart 希望守护进程进程立即干净地退出，释放所有资源。如果一个进程在收到 SIGTERM 信号后不退出，upstart 将对其发送 SIGKILL 信号。</p>
<h3 id="日常upstart命令"><a href="#日常upstart命令" class="headerlink" title="日常upstart命令"></a>日常upstart命令</h3><table>
<thead>
<tr>
<th>全部</th>
<th>简写</th>
</tr>
</thead>
<tbody>
<tr>
<td>initctl start</td>
<td>start</td>
</tr>
<tr>
<td>initctl restart</td>
<td>restart</td>
</tr>
<tr>
<td>initctl reload</td>
<td>reload</td>
</tr>
<tr>
<td>initctl stop</td>
<td>stop</td>
</tr>
</tbody>
</table>
<h3 id="编写upstart配置文件"><a href="#编写upstart配置文件" class="headerlink" title="编写upstart配置文件"></a>编写upstart配置文件</h3><ol>
<li>upstart脚本必须包含一个exec或者script片段，用于启动你的程序</li>
<li>pre-start script and post-stop script是一些钩子，可以在程序启动前后做一些事</li>
<li>start on and stop on定义了何时启动、停止你的程序</li>
</ol>
<hr>
<p>golang多用于写网络服务，以Nginx的官方upstart脚本为参考比较合适</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># http://wiki.nginx.org/upstart</span><br><span class="line"># nginx</span><br><span class="line"></span><br><span class="line">description &quot;nginx http daemon&quot;</span><br><span class="line">author &quot;George Shammas &lt;georgyo@gmail.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">start on (filesystem and net-device-up IFACE!=lo) 两个条件 文件系统和网络设备启动以后</span><br><span class="line">stop on runlevel [!2345]</span><br><span class="line"></span><br><span class="line">env DAEMON=/usr/sbin/nginx</span><br><span class="line">env PID=/var/run/nginx.pid</span><br><span class="line"></span><br><span class="line">expect fork</span><br><span class="line">respawn</span><br><span class="line">respawn limit 10 5</span><br><span class="line">#oom never</span><br><span class="line"></span><br><span class="line">pre-start script</span><br><span class="line">        $DAEMON -t</span><br><span class="line">        if [ $? -ne 0 ] 判断nginx -t命令的返回值是否是0(不是EXIT_SUCCESS)</span><br><span class="line">                then exit $?</span><br><span class="line">        fi</span><br><span class="line">end script</span><br><span class="line"></span><br><span class="line">exec $DAEMON</span><br></pre></td></tr></table></figure>
<p>简单写一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># /etc/init/naievehttpserver.conf</span><br><span class="line">description &quot;naive http golang server&quot;</span><br><span class="line">author &quot;xxx&quot;</span><br><span class="line"></span><br><span class="line">start on (filesystem and net-device-up IFACE!=lo)</span><br><span class="line">stop on runlevel [!2345]</span><br><span class="line"></span><br><span class="line">respawn</span><br><span class="line"></span><br><span class="line">chdir /vagrant</span><br><span class="line"></span><br><span class="line">exec ./naivehttpserver</span><br></pre></td></tr></table></figure>
<p>这样，就可以使用<code>sudo start naivehttpserver</code>这样的命令来管理naivehttpserver服务了。</p>
<p>更全的用法可以看<a href="http://upstart.ubuntu.com/cookbook/" target="_blank" rel="noopener">http://upstart.ubuntu.com/cookbook/</a>和<a href="http://upstart.ubuntu.com/wiki/" target="_blank" rel="noopener">http://upstart.ubuntu.com/wiki/</a></p>
<h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h3><p>目前upstart有被systemd取代的趋势, 列一些资料</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html</a></li>
<li><a href="https://wiki.archlinux.org/index.php/systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87</a>)</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/index.html" target="_blank" rel="noopener">浅析 Linux 初始化 init 系统，第 2 部分</a></p>
<p><a href="http://upstart.ubuntu.com/getting-started.html" target="_blank" rel="noopener">http://upstart.ubuntu.com/getting-started.html</a></p>
<p><a href="http://blog.fens.me/linux-upstart/" target="_blank" rel="noopener">http://blog.fens.me/linux-upstart/</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/后端/">后端</a><a href="/tags/linux/">linux</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/02/25/linux服务管理-upstart/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/13/慢请求性能优化-300倍性能提升/"><span>请求优化-百倍性能提升</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/13/慢请求性能优化-300倍性能提升/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-13T06:02:29.000Z">
          2018-02-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="发现慢请求"><a href="#发现慢请求" class="headerlink" title="发现慢请求"></a>发现慢请求</h3><p>我们的整个web服务是基于Rails的，应用服务器是基于多进程模型的unicorn，因此，慢请求会对系统造成比较大的影响。</p>
<p>最近又到了春节促销活动时期，为了更及时地发现整个后端系统的问题，我基于Kibana的Visulize功能制作了一个慢请求监控图</p>
<p><img src="http://7xqlni.com1.z0.glb.clouddn.com/kibanaa.png" alt=""></p>
<p>通过这个统计图，可以很方便的看出过去N分钟内，响应时间最慢的接口分布情况。</p>
<h3 id="优化-Cache"><a href="#优化-Cache" class="headerlink" title="优化-Cache"></a>优化-Cache</h3><p>对于图中这个<code>api/v1/publishers</code>接口，会出现很多耗时<code>100ms以上</code>的请求，这个接口做了以下几件事。</p>
<ol>
<li>查询数据库，加载一个几乎不怎么变动的publisher列表</li>
<li>渲染成json返回</li>
</ol>
<p>显而易见的优化策略就是cache掉数据库查询，做完这一步的确也能获得比较大的提升，普通的优化工作可能到这一步就结束了。</p>
<p>但是还有一个特殊的地方，这个列表可能有几百个条目，相对来说还是比较大的。而ruby在做这种CPU密集的渲染时，性能是非常差的。因此，也要想办法解决掉渲染的问题。</p>
<h3 id="优化-Render"><a href="#优化-Render" class="headerlink" title="优化-Render"></a>优化-Render</h3><p>只render一次。</p>
<p>相比于之前cache数据库查询的结果的方式，这次在代码中计算出最终返回的json，直接cache这个json字符串。</p>
<p>然后，在渲染的时候，使用渲染文本，并手动设置content-type的方式来返回json</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render <span class="symbol">plain:</span> <span class="string">"字符串"</span>, <span class="symbol">content_type:</span> <span class="string">'application/json'</span></span><br></pre></td></tr></table></figure>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>做完以上两步，在日志中观察到单个请求的时间降低到<code>0.8ms</code>左右！</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>以上优化差不多是Rails框架内的极致，再往上，可以考虑直接把数据静态化成json文件，交给Nginx管理。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/后端/">后端</a><a href="/tags/ELK/">ELK</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/02/13/慢请求性能优化-300倍性能提升/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/07/也谈服务注册与发现/"><span>也谈服务注册与发现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/07/也谈服务注册与发现/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-07T05:22:25.000Z">
          2018-02-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>公司后端是基于ROR的，应用服务器是unicorn，搞活动高峰期，缺乏一种动态改变配置后，就可以控制程序行为的能力。</p>
<p>受限于Rails和Unicorn的多进程模型，初步的方案就是往Cache里扔一个值，接口每次都检查这个值，但这样就多了一次<strong>网络IO</strong>，不太Geek。</p>
<p>深入思考了一下，觉得可以做一个配置中心，unicorn启动的时候,建立长连接到配置中心获取数据，配置发生改变的时候通过长连接通知到unicorn，从而动态改变了所有服务器上的本地内存。然后又在考虑，是每个unicorn worker都保持一个连接？还是只有master保持连接，通过一些进程间通信技术通知到worker？又或者单独做一个agent，让agent去保持连接，然后写到unix socket里，unicorn读这个socket？…</p>
<p>最终由于改不动unicorn的代码, 放弃了。</p>
<p><img src="http://7xqlni.com1.z0.glb.clouddn.com/think.jpg" alt=""></p>
<p>后来转念一想，这不就是etcd解决的问题!只不过详细的方案还需要基于etcd自己设计。</p>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>服务有一个唯一id，id是调用方和提供方都知道的。</p>
<p>大致流程:</p>
<ul>
<li>提供方： 往etcd里put一个键值对，key是服务id，值是对应的配置</li>
<li>掉用方： 根据key向etcd获取配置，并进行watch</li>
<li>配置改变时,调用方可以通过watch得知</li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>根据官方文档装好etcd,<a href="https://coreos.com/etcd/docs/latest/dl_build.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/dl_build.html</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/coreos/etcd.git</span><br><span class="line"><span class="built_in">cd</span> etcd</span><br><span class="line">./build</span><br><span class="line">./bin/etcd</span><br></pre></td></tr></table></figure>
<p>写一个简单的服务注册<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"github.com/coreos/etcd/clientv3"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    id      <span class="keyword">string</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> info = ServiceInfo&#123;<span class="string">"/service/b"</span>, <span class="string">"10.1.1.60:8081"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cli, err := clientv3.New(clientv3.Config&#123;</span><br><span class="line">        Endpoints:   []<span class="keyword">string</span>&#123;<span class="string">"localhost:2379"</span>&#125;,</span><br><span class="line">        DialTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> cli.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, err := cli.Put(context.TODO(), info.id, info.address); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resp, err := cli.Get(context.TODO(), info.id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"resp: "</span>, resp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写个简单的go服务a, 通过etcd来发现服务b的地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/coreos/etcd/clientv3"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    id      <span class="keyword">string</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> info = ServiceInfo&#123;<span class="string">"/service/a"</span>, <span class="string">"10.1.1.59:8080"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> infoB = ServiceInfo&#123;id: <span class="string">"/service/b"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">"/"</span>, hello)</span><br><span class="line">        http.ListenAndServe(info.address, <span class="literal">nil</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    etcd()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"hello this is %s, B address is %s"</span>, info.id, infoB.address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">etcd</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cli, err := clientv3.New(clientv3.Config&#123;</span><br><span class="line">        Endpoints:   []<span class="keyword">string</span>&#123;<span class="string">"localhost:2379"</span>&#125;,</span><br><span class="line">        DialTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> cli.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// regist self</span></span><br><span class="line">    <span class="keyword">if</span> _, err := cli.Put(context.TODO(), info.id, info.address); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get service b info</span></span><br><span class="line">    <span class="keyword">if</span> resp, err := cli.Get(context.TODO(), infoB.id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, ev := <span class="keyword">range</span> resp.Kvs &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%s : %s\n"</span>, ev.Key, ev.Value)</span><br><span class="line">            infoB.address = <span class="keyword">string</span>(ev.Value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// watch changes</span></span><br><span class="line">    rch := cli.Watch(context.TODO(), infoB.id, clientv3.WithPrefix())</span><br><span class="line">    <span class="keyword">for</span> wresp := <span class="keyword">range</span> rch &#123;</span><br><span class="line">        <span class="keyword">for</span> _, ev := <span class="keyword">range</span> wresp.Events &#123;</span><br><span class="line">            log.Printf(<span class="string">"%s %q : %q\n"</span>, ev.Type, ev.Kv.Key, ev.Kv.Value)</span><br><span class="line">            infoB.address = <span class="keyword">string</span>(ev.Kv.Value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是， a服务可以获取到b的地址，在<code>/service/b</code>这个key改变时，也可以通过watch得到最新的值。</p>
<h3 id="服务挂掉的处理"><a href="#服务挂掉的处理" class="headerlink" title="服务挂掉的处理"></a>服务挂掉的处理</h3><p>如果服务挂了，以上的方式是无法处理的，解决方式是给key设置一个ttl,每隔一段时间刷新ttl。通过这种类似心跳的方式来实现。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://github.com/coreos/etcd/blob/a0e17f69a2e060250251e1c31f6d8dde01cc4932/clientv3/example_kv_test.go" target="_blank" rel="noopener">https://github.com/coreos/etcd/blob/a0e17f69a2e060250251e1c31f6d8dde01cc4932/clientv3/example_kv_test.go</a></li>
<li><a href="https://github.com/coreos/etcd/blob/a0e17f69a2e060250251e1c31f6d8dde01cc4932/clientv3/example_watch_test.go" target="_blank" rel="noopener">https://github.com/coreos/etcd/blob/a0e17f69a2e060250251e1c31f6d8dde01cc4932/clientv3/example_watch_test.go</a></li>
<li><a href="https://coreos.com/etcd/docs/latest/dl_build.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/dl_build.html</a></li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/etcd/">etcd</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/02/07/也谈服务注册与发现/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/05/FishChatServer源码探究/"><span>FishChatServer源码探究</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/05/FishChatServer源码探究/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-05T09:53:02.000Z">
          2018-02-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在写im-go的过程中遇到了一些设计上的问题，于是想找目前有的开源im服务的源码看看。<a href="https://github.com/oikomi/FishChatServer2" target="_blank" rel="noopener">FishChatServer2</a>在一些模块设计上和我的思路很相似，有种英雄所见略同的快感，所以选了它(FishChatServer2的拆包方式和我<a href="https://moonshining.github.io/blog/2018/02/05/golang-tcp%E6%8B%86%E5%8C%85%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF">上一篇文章</a>中提到的使用<code>ReadFull</code>的方式是一样的，并且连模块名字都一样叫Codec)</p>
<p>主要看了libnet和server两个模块</p>
<p>libnet, 是所有server的基础公共库，封装了诸如Listen Accept之类的调用<br><img src="http://7xqlni.com1.z0.glb.clouddn.com/libnet.png" alt=""></p>
<p>server, 具体的服务，看了一下gateway和access两个服务的实现<br><img src="http://7xqlni.com1.z0.glb.clouddn.com/server.png" alt=""></p>
<hr>
<h3 id="gateway服务"><a href="#gateway服务" class="headerlink" title="gateway服务"></a>gateway服务</h3><p><strong>gateway.go</strong>是gateway服务的入口，其实是一个access服务的负载均衡器，核心代码如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化对象</span></span><br><span class="line">gwServer := server.New() </span><br><span class="line"><span class="comment">// codec编码、解码器</span></span><br><span class="line">protobuf := codec.Protobuf() </span><br><span class="line"><span class="comment">// 使用libnet封装的api进行Listen</span></span><br><span class="line"><span class="keyword">if</span> gwServer.Server, err = libnet.Serve(conf.Conf.Server.Proto, conf.Conf.Server.Addr, protobuf, <span class="number">0</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    glog.Error(err)</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 通过etcd进行服务发现，每5秒向etcd请求一个access服务器列表，并写入AccessServerList 这个变量中</span></span><br><span class="line"><span class="keyword">go</span> job.ConfDiscoveryProc() </span><br><span class="line">gwServer.Loop() <span class="comment">// 开始不断循环处理请求</span></span><br></pre></td></tr></table></figure>
<p><code>gwServer.Loop()</code>的核心代码在<strong>server.go</strong>中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">sessionLoop</span><span class="params">(client *client.Client)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//读一个包</span></span><br><span class="line">        reqData, err := client.Session.Receive() </span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Error(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> reqData != <span class="literal">nil</span> &#123;</span><br><span class="line">            baseCMD := &amp;external.Base&#123;&#125;</span><br><span class="line">            <span class="comment">// protobuf 反序列化</span></span><br><span class="line">            <span class="keyword">if</span> err = proto.Unmarshal(reqData, baseCMD); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err = client.Session.Send(&amp;external.Error&#123;</span><br><span class="line">                    Cmd:     external.ErrServerCMD,</span><br><span class="line">                    ErrCode: ecode.ServerErr.Uint32(),</span><br><span class="line">                    ErrStr:  ecode.ServerErr.String(),</span><br><span class="line">                &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    glog.Error(err)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// client.Parse方法有一点迷惑性，client.Parse 其实做了解析命令，并执行命令的工作</span></span><br><span class="line">            <span class="keyword">if</span> err = client.Parse(baseCMD.Cmd, reqData); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                glog.Error(err)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Loop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    glog.Info(<span class="string">"loop"</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 获取libnet封装的session对象</span></span><br><span class="line">        session, err := s.Server.Accept() </span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Error(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成client对象，里面封装了gateway服务的业务逻辑</span></span><br><span class="line">        <span class="keyword">go</span> s.sessionLoop(client.New(session)) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client.Parse最终调用了<strong>proto_proc.go</strong>里的<strong>client.procReqAccessServer</strong>来执行业务逻辑<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">procReqAccessServer</span><span class="params">(reqData []<span class="keyword">byte</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> addr <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> accessServerList []<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// 从之前提到的access服务地址数组中获取一个可用的access服务</span></span><br><span class="line">    <span class="comment">// 没有看懂为什么要做一次额外的复制数组的操作？</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> job.AccessServerList &#123;</span><br><span class="line">        accessServerList = <span class="built_in">append</span>(accessServerList, v.IP)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理错误情况</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(accessServerList) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err = c.Session.Send(&amp;external.ResSelectAccessServerForClient&#123;</span><br><span class="line">            Cmd:     external.ReqAccessServerCMD,</span><br><span class="line">            ErrCode: ecode.NoAccessServer.Uint32(),</span><br><span class="line">            ErrStr:  ecode.NoAccessServer.String(),</span><br><span class="line">        &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Error(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个可用地址</span></span><br><span class="line">    addr = accessServerList[rand.Intn(<span class="built_in">len</span>(accessServerList))]</span><br><span class="line">    <span class="keyword">if</span> err = c.Session.Send(&amp;external.ResSelectAccessServerForClient&#123;</span><br><span class="line">        Cmd:     external.ReqAccessServerCMD,</span><br><span class="line">        ErrCode: ecode.OK.Uint32(),</span><br><span class="line">        ErrStr:  ecode.OK.String(),</span><br><span class="line">        Addr:    addr,</span><br><span class="line">    &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Error(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此一次请求就结束了，可用看出代码的结构上非常清晰，很容易就能理解。</p>
<hr>
<h3 id="libnet"><a href="#libnet" class="headerlink" title="libnet"></a>libnet</h3><p>这个模块帮我们屏蔽了大量繁琐的网络细节，接下来就要看一下它的实现了。</p>
<p>从<strong>api.go</strong>入手，这里定义了对外的接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Protocol <span class="keyword">interface</span> &#123; </span><br><span class="line">    <span class="comment">// Codec 负责通信协议的解析，封装了读写数据的方法</span></span><br><span class="line">    NewCodec(rw io.ReadWriter) Codec </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Codec <span class="keyword">interface</span> &#123;</span><br><span class="line">    Receive() ([]<span class="keyword">byte</span>, error)</span><br><span class="line">    Send(<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(network, address <span class="keyword">string</span>, protocol Protocol, sendChanSize <span class="keyword">int</span>)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">    listener, err := net.Listen(network, address) <span class="comment">// 终于看到标准库里的东西了</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// listener用于Accept， protocol用户处理net.Conn, sendChanSize看上去好像是用来控制发送速率的，不过没有明白为什么需要控制?</span></span><br><span class="line">    <span class="keyword">return</span> NewServer(listener, protocol, sendChanSize), <span class="literal">nil</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端连接+带超时的连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Connect</span><span class="params">(network, address <span class="keyword">string</span>, protocol Protocol, sendChanSize <span class="keyword">int</span>)</span> <span class="params">(*Session, error)</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(network, address)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NewSession(protocol.NewCodec(conn), sendChanSize), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConnectTimeout</span><span class="params">(network, address <span class="keyword">string</span>, timeout time.Duration, protocol Protocol, sendChanSize <span class="keyword">int</span>)</span> <span class="params">(*Session, error)</span></span> &#123;</span><br><span class="line">    conn, err := net.DialTimeout(network, address, timeout)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NewSession(protocol.NewCodec(conn), sendChanSize), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跳过客户的部分的实现，探索一下<strong>server.go</strong>,负责Accept一个连接，并且封装好一个session对象返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">Accept</span><span class="params">()</span> <span class="params">(*Session, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := server.listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 处理Temporary Error应该是参考了goblog里的error-handling-and-go章节</span></span><br><span class="line">            <span class="comment">// For instance, a web crawler might sleep and retry when it encounters a temporary error and give up otherwise.</span></span><br><span class="line">            <span class="keyword">if</span> ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 感觉直接比较字符串有点太粗暴了？ 但应该是没有办法区分的原因</span></span><br><span class="line">            <span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">"use of closed network connection"</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, io.EOF</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> server.manager.NewSession(</span><br><span class="line">            server.protocol.NewCodec(conn),</span><br><span class="line">            server.sendChanSize,</span><br><span class="line">        ), <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>manager.go</strong>用于管理session，会把session根据id mod 32以后，放进对应的map里, 这里使用了lock来保证并发安全, 但golang1.9以后，应该可以用内置的<strong>sync.Map</strong>替代了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">NewSession</span><span class="params">(codec Codec, sendChanSize <span class="keyword">int</span>)</span> *<span class="title">Session</span></span> &#123;</span><br><span class="line">    session := newSession(manager, codec, sendChanSize)</span><br><span class="line">    manager.putSession(session)</span><br><span class="line">    <span class="keyword">return</span> session</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">putSession</span><span class="params">(session *Session)</span></span> &#123;</span><br><span class="line">    smap := &amp;manager.sessionMaps[session.id%sessionMapNum]</span><br><span class="line">    smap.Lock()</span><br><span class="line">    <span class="keyword">defer</span> smap.Unlock()</span><br><span class="line">    smap.sessions[session.id] = session</span><br><span class="line">    manager.disposeWait.Add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>server在Accept之后，返回的是一个session对象,session负责收发数据，并且实现了<strong>优雅退出(gracefully shutdown)</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Session <span class="keyword">struct</span> &#123;</span><br><span class="line">    id             <span class="keyword">uint64</span></span><br><span class="line">    codec          Codec</span><br><span class="line">    manager        *Manager</span><br><span class="line">    sendChan       <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    closeFlag      <span class="keyword">int32</span></span><br><span class="line">    closeChan      <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    closeMutex     sync.Mutex</span><br><span class="line">    closeCallbacks *list.List</span><br><span class="line">    State          <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优雅退出的实现，先通过CAS设置一下closeFlag, 成功设置的gorutine可以执行清理操作，失败的gorutine返回SessionClosedError<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(session *Session)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果成功通过CAS设置了closeFlag</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;session.closeFlag, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        err := session.codec.Close() <span class="comment">// 关闭net.Conn</span></span><br><span class="line">        <span class="built_in">close</span>(session.closeChan) <span class="comment">// 退出sendLoop</span></span><br><span class="line">        <span class="keyword">if</span> session.manager != <span class="literal">nil</span> &#123; <span class="comment">// 从manager中移除session</span></span><br><span class="line">            session.manager.delSession(session)</span><br><span class="line">        &#125;</span><br><span class="line">        session.invokeCloseCallbacks() <span class="comment">// 执行callback</span></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SessionClosedError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发送数据部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func (session *Session) sendLoop() &#123;</span><br><span class="line">    defer session.Close()</span><br><span class="line">    for &#123;</span><br><span class="line">        // 使用select语句来保证，关闭closeChan之后可以退出sendLoop</span><br><span class="line">        select &#123;</span><br><span class="line">        case msg := &lt;-session.sendChan:</span><br><span class="line">            if session.codec.Send(msg) != nil &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">        case &lt;-session.closeChan:</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (session *Session) Send(msg interface&#123;&#125;) (err error) &#123;</span><br><span class="line">    // 在每次Send的时候，都会检查closeFlag，实现快速的退出</span><br><span class="line">    if session.IsClosed() &#123;</span><br><span class="line">        return SessionClosedError</span><br><span class="line">    &#125;</span><br><span class="line">    if session.sendChan == nil &#123;</span><br><span class="line">        return session.codec.Send(msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // send block, 返回一个异常, 有点粗暴了</span><br><span class="line">    select &#123;</span><br><span class="line">    case session.sendChan &lt;- msg:</span><br><span class="line">        return nil</span><br><span class="line">    default:</span><br><span class="line">        return SessionBlockedError</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>其实本意是想找找有没有关于心跳和连接保持方面的代码，但没有什么收获.不过也看到了很多高质量的实现，例如<strong>idgen</strong>，粗粗瞟了一眼就发现，应该是使用了雪花算法，此外还有大量微服务的设计，以及一些我很感兴趣的流行开源技术栈(k8s docker etcd hbase kafka)可以看出是一整套经过深思熟虑的系统，决定过年期间要好好看一看这个库，吸收一下营养。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/造轮子/">造轮子</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/02/05/FishChatServer源码探究/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/05/golang-tcp拆包的正确姿势/"><span>golang tcp拆包的正确姿势</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/05/golang-tcp拆包的正确姿势/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-05T03:07:59.000Z">
          2018-02-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>最近在造一个叫im-go的服务，看名字也能猜出来，是一个基于Go的IM服务，因为不想引入任何的依赖库，所以是手写每个模块的。</p>
<p>之前看过Netty，于是也想做一个类似Netty Codec的，用于编码解码的模块, 方便地处理TCP粘包这种细节问题。</p>
<p>在网上做了一番搜索之后，发现排名靠前的实现，要么出乎意料地复杂，要么根本就是完全错误的，例如</p>
<p>出乎意料的复杂：</p>
<ul>
<li><a href="http://xiaorui.cc/2016/03/08/%E8%A7%A3%E5%86%B3golang%E5%BC%80%E5%8F%91socket%E6%9C%8D%E5%8A%A1%E6%97%B6%E7%B2%98%E5%8C%85%E5%8D%8A%E5%8C%85bug" target="_blank" rel="noopener">解决golang开发socket服务时粘包半包bug</a></li>
<li><a href="golang中tcp socket粘包问题和处理">http://www.01happy.com/golang-tcp-socket-adhere/</a></li>
</ul>
<p>错误的：</p>
<ul>
<li><a href="服务器的粘包处理">https://victoriest.gitbooks.io/golang-tcp-server/content/chapter4.html</a></li>
</ul>
<p>分析一下这个错误的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(reader *bufio.Reader)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    lengthByte, _ := reader.Peek(<span class="number">4</span>)</span><br><span class="line">    lengthBuff := bytes.NewBuffer(lengthByte)</span><br><span class="line">    <span class="keyword">var</span> length <span class="keyword">int32</span></span><br><span class="line">    err := binary.Read(lengthBuff, binary.LittleEndian, &amp;length)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">int32</span>(reader.Buffered()) &lt; length+<span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设执行到了这里，那么已经成功读取了长度到length这个变量中</span></span><br><span class="line">    pack := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="keyword">int</span>(<span class="number">4</span>+length))</span><br><span class="line">    _, err = reader.Read(pack) <span class="comment">//这里是不能保证就能完读到length长度的数据的!!</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(pack[<span class="number">4</span>:]), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我也受了它的误导，基于<a href="https://golang.org/pkg/bufio/#Reader.Peek" target="_blank" rel="noopener">Peek()</a>做了一个非常复杂的实现</p>
<h3 id="正确的姿势"><a href="#正确的姿势" class="headerlink" title="正确的姿势"></a>正确的姿势</h3><p>在翻了翻io和bufio这两个包之后，我找到了<a href="https://golang.org/pkg/io/#ReadFull" target="_blank" rel="noopener">ReadFull</a></p>
<p>ReadFull，就是调用了ReadAtLeast</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ReadAtLeast(r, buf, <span class="built_in">len</span>(buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAtLeast</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>, min <span class="keyword">int</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(buf) &lt; min &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, ErrShortBuffer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> n &lt; min &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> nn <span class="keyword">int</span></span><br><span class="line">        nn, err = r.Read(buf[n:])</span><br><span class="line">        n += nn</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n &gt;= min &#123;</span><br><span class="line">        err = <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; err == EOF &#123;</span><br><span class="line">        err = ErrUnexpectedEOF</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准库里的ReadAtLeast就非常优雅了，用n记录读取的总字节数，nn是每次读取到的字节数，一看就明白。</p>
<p>基于ReadFull的拆包代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *LenthCodec)</span> <span class="title">Decode</span><span class="params">(conn net.Conn)</span> <span class="params">(bodyBuf []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">    lengthBuf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">    _, err = io.ReadFull(conn, lengthBuf)</span><br><span class="line">    <span class="comment">//check error</span></span><br><span class="line">    length := binary.LittleEndian.Uint32(lengthBuf)</span><br><span class="line">    </span><br><span class="line">    bodyBuf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, length)</span><br><span class="line">    _, err = io.ReadFull(conn, bodyBuf)</span><br><span class="line">    <span class="comment">//check error</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/造轮子/">造轮子</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/02/05/golang-tcp拆包的正确姿势/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/01/05/后端的一些经验与心得/"><span>后端一年(经验与心得)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/01/05/后端的一些经验与心得/" rel="bookmark">
        <time class="entry-date published" datetime="2018-01-05T01:54:10.000Z">
          2018-01-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>先简单介绍一下我的经历，最早在学校的时候，是在社团里写php和Java，创业时期写js，oc和Ruby，现在是全职用Rails写后端了。</p>
<h4 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h4><p>我们的主要业务有两块，社区和电商</p>
<p>整体业务的峰值qps大概在3000，也算是pv过10亿的站点了，后端team有4个人，除了一个八年老司机，其他人参加工作的年限都不是太久。</p>
<p>我们面对的是一个巨大的基于Rails的历史遗留系统，最早的开发成员均已离开，导致我们常常面对遗留代码一脸蒙逼，到处是没有人知道的逻辑，丑陋的实现，以及很多性能跟不上的接口。</p>
<h4 id="与巨石应用的斗争"><a href="#与巨石应用的斗争" class="headerlink" title="与巨石应用的斗争"></a>与巨石应用的斗争</h4><p>日常工作的重中之重，就是与这个monolith的战斗！</p>
<p><strong>性能篇</strong></p>
<p>以往每年我们搞活动，服务器都会挂，经济损失不少，所以优化性能，保证活动期间的访问是第一要务。</p>
<p>原来的活动整体设计还是比较科学的，活动页面本身是静态化的，主要瓶颈是商品详情页面。</p>
<p>我们利用redis做了三层cache，解决了这个问题。第一层是数据库的缓存，直接把商品信息缓存到redis里，避免了频繁的数据库访问，第二层是单条数据的渲染缓存，可以理解成一小段html，第三层是整个数据集的渲染缓存。</p>
<p>第二个瓶颈出现在一些静态资源上，全面迁移到云存储解决。做完这两件事之后，上上次活动是我们有史以来第一次，没有挂。</p>
<p>就在我们觉得，优化做的不错的时候，上次活动却又挂了。</p>
<p>要知道我们特意买了新服务器，美滋滋觉得这下稳了，没想到…</p>
<p>上次活动挂的原因有以下几点</p>
<ol>
<li>redis hmget，我们通过gem提供的API，缓存了一个巨大的省市区列表，但是没有注意到缓存是分离的，获取整个列表，其实就是一条hmget获取所有独立的缓存片段，这个操作block了redis，导致访问极度缓慢。我们紧急把整个列表转成json，直接贴到代码里返回hotfix了这个问题</li>
<li>突然无法通过redis sential进行连接，这套sential系统是由已经离职的运维搭建的，我们绕开sential直接连接redis，解决了这个问题</li>
<li>fd limit,发现依然是1024，修改后却依然时常502，发现运维修改的是root用户的fd数量…坑爹！</li>
<li>在支付回调中有一段用于统计的sql，订单量大了以后slow query，block了数据库，我们直接注释了这段可有可无的老代码，解决。</li>
</ol>
<p>总结一下，对于web应用的场景来说，大都是读多写少，缓存读请求，异步写请求，是我们经常采用的两种效果不错的方式。在数据库层面，对于遗留代码中效率低下的查询进行重写，重点改写了所有N＋1查询，对一些逐条插入的语句用batch insert合并写入操作，也有不错的提升。</p>
<p><strong>替换篇</strong></p>
<p>做的比较有意思的事，是写了我们内部用的个推GEM。原来使用的是github上开源的一个GEM，但是已经很久没更新了，无法适应我们的使用需求。我基于个推最新的HTTPS的API，写了一个Ruby的包装。</p>
<p>这里要吐槽的是个推的技术水平。推送服务是做的不错，但API怎么做的这么low。他们定义了一个叫authorize的http header用来传递身份信息…违背了RFC关于HTTP头必须大写开头的规范。一些语言的标准库(Go、Ruby…)会自动帮你把authorize转化成Authorize，导致个推那边一直返回auth error…而个推的接口又是HTTPS的，抓包调试很困难，浪费了我很长时间调试这个问题。</p>
<p><strong>重构篇</strong><br>重构的主要方针就是拆分，尽可能把功能从巨石应用中拆出去。如果一时半会难以拆分的，代码上也尽可能让逻辑高度内聚，方便以后迁移。</p>
<p>消息系统的重构<br>消息系统是一个，出点问题没什么，但做得好会非常出彩的功能。我一直觉得，像知乎这种社区的成功，除了内容，很大一部分要归功于消息的体验。目前，我们几乎所有页面，都会展示新消息的数量，导致每次请求都会去主数据库的消息表做count，计算各种消息的数量返回给前端。我正在着手把整个系统迁移到另一个独立的数据库，以后可以作为单独的服务供内部调用，降级限流什么的都很方便。</p>
<p>搜索的重构</p>
<p>原来的搜索是基于Solr的java工程，是一个我们内部没人维护好多年的烂摊子，虽然各方面表现都不错。我们使用了用Elasticsearch替换掉了。</p>
<p><strong>新系统</strong><br>我新写了内部的财务系统，过程中遇到很多问题，写的也很痛苦，但最终效果还是不错。因为原来的各种报表都是直接基于生产数据库的，对业务会有冲击，新系统写了一个同步模块，可以增量同步订单数据到财务系统的专用数据库，这样就不会对业务带来影响。</p>
<p>遇到的比较大的坑就是内存爆炸。有一些耗时计算我放到了消息对列里，整个worker进程的内存占用疯狂上升。最终发现是Ruby内存模型的特点，分配大量对象，却不进行回收。需要你使用batch处理的方式，切成一小块一小块的数据，一次处理一小块，这样下次计算的时候就可以重用之前申请的那些对象。</p>
<p>另外也通过时间换空间的方式，把加载全部数据做计算，改成了加载部分数据做计算，然后汇总结果这样的方式，极大降低了内存占用，并每天重启worker进程，解决了最主要的内存问题(1G内存的机器…)。</p>
<p>这个项目让我真实感觉到，有些场景真的不是Ruby擅长的领域。Ruby的内存模型，就是尽量分配对象，从不真正回收，只会重用。Ruby VM启动就有大量空对象等着被分配，假如我加载了很多数据，空对象不够用了，VM就向操作系统申请一批内存，用完后也不释放，等着下次重用。而报表计算的最佳场景就是能加载大量数据，算一下结果，算完释放掉内存。</p>
<p><strong>监控</strong><br>可以看我之前的文章<a href="http://www.jianshu.com/p/69ce51cfcb3d" target="_blank" rel="noopener">使用ELK构建分布式日志分析系统</a></p>
<p><strong>代码篇</strong><br>在日常编码、重构的过程中，经常使用的技术是</p>
<ol>
<li>设计模式</li>
<li>元编程</li>
<li>自动化测试</li>
</ol>
<p>运用设计模式，写出符合OOP规范的代码。分割每个类的职责，尽量让各个功能的逻辑内聚，只提供彼此间调用的接口，这是我最近才刚领悟的代码整洁之道。</p>
<p>元编程抽象代码，我很早就在使用的奇技淫巧。现在却用的越来越少了，因为它违背了OOP，可维护性比较差，对使用者的水平有很大要求，也容易<strong>坑队友</strong>。</p>
<p>简单地说，我代码中的if/else越来越少了，类越来越多了，改动起来越来方便了，改动影响的部分越来少了，美滋滋。</p>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>用一句古老的名言，软件开发没有银弹。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/后端/">后端</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/01/05/后端的一些经验与心得/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
  </p>
</footer>
    
  </div>
</div>
</body>
</html>