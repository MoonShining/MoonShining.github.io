<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Moon&#39;s blog | write the code, change the world.</title>

  
  <meta name="author" content="Moon">
  

  
  <meta name="description" content="Ruby\Golang">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Moon&#39;s blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Moon&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?a9ab16fc25a6e74e9e3521e7ad3782e8";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Moon&#39;s blog</a>
    </h1>
    <p class="site-description">write the code, change the world.</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/12/Time-Wheel-高效定时器/"><span>Time Wheel-高效定时器</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/12/Time-Wheel-高效定时器/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-12T02:44:25.000Z">
          2018-04-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>之前的文章中有提到过基于最小堆构建定时器的方式，这里介绍另一种更酷的实现–Time Wheel(时间轮)</p>
<h3 id="数据结构分析"><a href="#数据结构分析" class="headerlink" title="数据结构分析"></a>数据结构分析</h3><p><img src="http://7xqlni.com1.z0.glb.clouddn.com/1348926970_9123.png" alt="1348926970_9123.png"></p>
<p>解释一下上图，环里是一个个的时间间隔，链表中是到达这个时间点后需要触发的定时事件。</p>
<p>举个例子，假设环中的一格代表1s。</p>
<p>如果我有一个需要延迟3s执行的任务，当前TimeWheel位于1处，那么就把它放入第4格的链表中。</p>
<p>如果需要延迟10s，那么10%8 + 1 = 3， 就放入3处。当然，我们需要记录一下，这个事件需要等TimeWheel第二次转到3处才能触发。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><table>
<thead>
<tr>
<th>底层结构</th>
<th>添加定时器</th>
<th>触发定时器</th>
<th>PerTickBookkeeping</th>
</tr>
</thead>
<tbody>
<tr>
<td>最小堆</td>
<td>O(lg(n))</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>时间轮</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3 id="缺点与优化"><a href="#缺点与优化" class="headerlink" title="缺点与优化"></a>缺点与优化</h3><p>可以看出，如果我需要延迟1天执行，那么会创建一个很大的环形链表，虽然可以通过降低精度来减少内存消耗，但我们需要更好的方案。</p>
<p>我们可以组合多个timewheel，来减少内存开销，同时保持很高的效率</p>
<p><img src="http://7xqlni.com1.z0.glb.clouddn.com/TimingWheels2.png" alt="TimingWheels2.png"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> timewheel</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"container/list"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// @author qiang.ou&lt;qingqianludao@gmail.com&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Job 延时任务回调函数</span></span><br><span class="line"><span class="keyword">type</span> Job <span class="function"><span class="keyword">func</span><span class="params">(TaskData)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">TaskData</span> 回调函数参数类型</span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">TaskData</span> <span class="title">map</span>[<span class="title">interface</span></span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TimeWheel 时间轮</span></span><br><span class="line"><span class="keyword">type</span> TimeWheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    interval time.Duration <span class="comment">// 指针每隔多久往前移动一格</span></span><br><span class="line">    ticker   *time.Ticker</span><br><span class="line">    slots    []*list.List <span class="comment">// 时间轮槽</span></span><br><span class="line">    <span class="comment">// key: 定时器唯一标识 value: 定时器所在的槽, 主要用于删除定时器, 不会出现并发读写，不加锁直接访问</span></span><br><span class="line">    timer             <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span></span><br><span class="line">    currentPos        <span class="keyword">int</span>              <span class="comment">// 当前指针指向哪一个槽</span></span><br><span class="line">    slotNum           <span class="keyword">int</span>              <span class="comment">// 槽数量</span></span><br><span class="line">    job               Job              <span class="comment">// 定时器回调函数</span></span><br><span class="line">    addTaskChannel    <span class="keyword">chan</span> Task        <span class="comment">// 新增任务channel</span></span><br><span class="line">    removeTaskChannel <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 删除任务channel</span></span><br><span class="line">    stopChannel       <span class="keyword">chan</span> <span class="keyword">bool</span>        <span class="comment">// 停止定时器channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 延时任务</span></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">    delay  time.Duration <span class="comment">// 延迟时间</span></span><br><span class="line">    circle <span class="keyword">int</span>           <span class="comment">// 时间轮需要转动几圈</span></span><br><span class="line">    key    <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 定时器唯一标识, 用于删除定时器</span></span><br><span class="line">    data   TaskData      <span class="comment">// 回调函数参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 创建时间轮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(interval time.Duration, slotNum <span class="keyword">int</span>, job Job)</span> *<span class="title">TimeWheel</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> interval &lt;= <span class="number">0</span> || slotNum &lt;= <span class="number">0</span> || job == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    tw := &amp;TimeWheel&#123;</span><br><span class="line">        interval:          interval,</span><br><span class="line">        slots:             <span class="built_in">make</span>([]*list.List, slotNum),</span><br><span class="line">        timer:             <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>),</span><br><span class="line">        currentPos:        <span class="number">0</span>,</span><br><span class="line">        job:               job,</span><br><span class="line">        slotNum:           slotNum,</span><br><span class="line">        addTaskChannel:    <span class="built_in">make</span>(<span class="keyword">chan</span> Task),</span><br><span class="line">        removeTaskChannel: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">        stopChannel:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tw.slotNum; i++ &#123;</span><br><span class="line">        tw.slots[i] = list.New()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start 启动时间轮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tw.ticker = time.NewTicker(tw.interval)</span><br><span class="line">    <span class="keyword">go</span> tw.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop 停止时间轮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tw.stopChannel &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddTimer 添加定时器 key为定时器唯一标识</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span> <span class="title">AddTimer</span><span class="params">(delay time.Duration, key <span class="keyword">interface</span>&#123;&#125;, data TaskData)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> delay &lt;= <span class="number">0</span> || key == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    tw.addTaskChannel &lt;- Task&#123;delay: delay, key: key, data: data&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RemoveTimer 删除定时器 key为添加定时器时传递的定时器唯一标识</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span> <span class="title">RemoveTimer</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    tw.removeTaskChannel &lt;- key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-tw.ticker.C:</span><br><span class="line">            tw.tickHandler()</span><br><span class="line">        <span class="keyword">case</span> task := &lt;-tw.addTaskChannel:</span><br><span class="line">            tw.addTask(&amp;task)</span><br><span class="line">        <span class="keyword">case</span> key := &lt;-tw.removeTaskChannel:</span><br><span class="line">            tw.removeTask(key)</span><br><span class="line">        <span class="keyword">case</span> &lt;-tw.stopChannel:</span><br><span class="line">            tw.ticker.Stop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span> <span class="title">tickHandler</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l := tw.slots[tw.currentPos]</span><br><span class="line">    tw.scanAndRunTask(l)</span><br><span class="line">    <span class="keyword">if</span> tw.currentPos == tw.slotNum<span class="number">-1</span> &#123;</span><br><span class="line">        tw.currentPos = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tw.currentPos++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描链表中过期定时器, 并执行回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span> <span class="title">scanAndRunTask</span><span class="params">(l *list.List)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; &#123;</span><br><span class="line">        task := e.Value.(*Task)</span><br><span class="line">        <span class="keyword">if</span> task.circle &gt; <span class="number">0</span> &#123;</span><br><span class="line">            task.circle--</span><br><span class="line">            e = e.Next()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> tw.job(task.data)</span><br><span class="line">        next := e.Next()</span><br><span class="line">        l.Remove(e)</span><br><span class="line">        <span class="built_in">delete</span>(tw.timer, task.key)</span><br><span class="line">        e = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增任务到链表中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span> <span class="title">addTask</span><span class="params">(task *Task)</span></span> &#123;</span><br><span class="line">    pos, circle := tw.getPositionAndCircle(task.delay)</span><br><span class="line">    task.circle = circle</span><br><span class="line"></span><br><span class="line">    tw.slots[pos].PushBack(task)</span><br><span class="line"></span><br><span class="line">    tw.timer[task.key] = pos</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取定时器在槽中的位置, 时间轮需要转动的圈数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span> <span class="title">getPositionAndCircle</span><span class="params">(d time.Duration)</span> <span class="params">(pos <span class="keyword">int</span>, circle <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    delaySeconds := <span class="keyword">int</span>(d.Seconds())</span><br><span class="line">    intervalSeconds := <span class="keyword">int</span>(tw.interval.Seconds())</span><br><span class="line">    circle = <span class="keyword">int</span>(delaySeconds / intervalSeconds / tw.slotNum)</span><br><span class="line">    pos = <span class="keyword">int</span>(tw.currentPos+delaySeconds/intervalSeconds) % tw.slotNum</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表中删除任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span> <span class="title">removeTask</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取定时器所在的槽</span></span><br><span class="line">    position, ok := tw.timer[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取槽指向的链表</span></span><br><span class="line">    l := tw.slots[position]</span><br><span class="line">    <span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; &#123;</span><br><span class="line">        task := e.Value.(*Task)</span><br><span class="line">        <span class="keyword">if</span> task.key == key &#123;</span><br><span class="line">            <span class="built_in">delete</span>(tw.timer, task.key)</span><br><span class="line">            l.Remove(e)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        e = e.Next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/ouqiang/timewheel" target="_blank" rel="noopener">https://github.com/ouqiang/timewheel</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-timers/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-timers/</a><br><a href="http://www.lpnote.com/2017/11/16/hashed-and-hierarchical-timing-wheels" target="_blank" rel="noopener">http://www.lpnote.com/2017/11/16/hashed-and-hierarchical-timing-wheels</a><br><a href="https://www.confluent.io/blog/apache-kafka-purgatory-hierarchical-timing-wheels/" target="_blank" rel="noopener">https://www.confluent.io/blog/apache-kafka-purgatory-hierarchical-timing-wheels/</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/数据结构/">数据结构</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/04/12/Time-Wheel-高效定时器/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/03/awk-like-a-boss/"><span>awk like a boss!</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/03/awk-like-a-boss/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-03T04:34:38.000Z">
          2018-04-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>linux提供了很多文本处理的屠龙刀，awk就是其中的佼佼者，称为一门面向文本的编程语言也不为过(awk中可以定义变量、进行运算，处理分支条件等等)。</p>
<p>如果早点学会awk，财务系统就不会写的这么费劲了，直接导出一份csv，写写awk脚本就好。</p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>完整的awd命令，可以由BEGIN BODY END三部分组成，其中BEGIN和END只会在awk执行前后运行一次，而BODY部分会每行不断处理。</p>
<p><img src="http://7xqlni.com1.z0.glb.clouddn.com/QQ截图20180403123540.png" alt="QQ截图20180403123540.png"></p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>下面是几个几个awk的例子</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只有 body 区域:</span></span><br><span class="line">awk -F: <span class="string">'&#123;print $1&#125;'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时具有 begin,body 和 end 区域:</span></span><br><span class="line">awk –F: <span class="string">'BEGIN&#123;printf "username\n-------\n"&#125;\</span></span><br><span class="line"><span class="string">&#123; print $1 &#125;\</span></span><br><span class="line"><span class="string">END &#123;print "----------" &#125;'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有 begin 和 body 区域:</span></span><br><span class="line">awk –F: <span class="string">'BEGIN &#123;print "UID"&#125; &#123;print $3&#125;'</span> /etc/passwd</span><br></pre></td></tr></table></figure>
<p>我们以<code>awk -F: &#39;{print $1}&#39; /etc/passwd</code>为例来看分析一下</p>
<ol>
<li>-F:指定了以：作为分隔符</li>
<li>‘{ print $1 }’ 表示输出第一个</li>
<li>/etc/passwd是输入的文件</li>
</ol>
<p>这个命令会输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">daemon</span><br><span class="line">bin</span><br><span class="line">sys</span><br><span class="line">sync</span><br><span class="line">games</span><br><span class="line">man</span><br><span class="line">lp</span><br><span class="line">mail</span><br><span class="line">news</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="指定分隔符"><a href="#指定分隔符" class="headerlink" title="指定分隔符"></a>指定分隔符</h3><p>默认的输入分隔符是空格，可以通过-F选项来指定<strong>输入字段分隔符</strong>，例如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk -F: <span class="string">'&#123;print $2&#125;'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line">awk -F, <span class="string">'&#123;print $2&#125;'</span> example.csv</span><br></pre></td></tr></table></figure>
<p>也可以通过设置OFS变量来指定<strong>输出字段分隔符</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F, <span class="string">'BEGIN &#123;OFS=":"&#125; &#123;print $2, $3&#125;'</span> employee.txt</span><br></pre></td></tr></table></figure>
<p>当一行容纳了多组数据时，awk允许你指定数据之间的分隔符，<strong>输入记录分隔符</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F, <span class="string">'BEGIN &#123; RS=":" &#125; &#123;print $2&#125;'</span> employee-one-line.txt</span><br></pre></td></tr></table></figure>
<p>在输出时，记录直接允许指定<strong>输出记录分隔符</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123;FS=&quot;,&quot;;ORS=&quot;\n---\n&quot;&#125; &#123;print $2,$3&#125;&apos; employee.txt</span><br></pre></td></tr></table></figure>
<p>$1、$2这样的变量代表分割后的字符串数组中的位置， $0代表整行</p>
<h3 id="Pattern-Maching"><a href="#Pattern-Maching" class="headerlink" title="Pattern Maching"></a>Pattern Maching</h3><p>当然，我们可以只处理一行中的某些部分，通过正则实现</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># employee.txt</span></span><br><span class="line"><span class="comment"># Jason Smith IT Manager</span></span><br><span class="line"><span class="comment"># Jane Miller Sales Manager</span></span><br><span class="line"><span class="comment"># vagrant@z:~/awk$ cat employee.txt</span></span><br><span class="line"><span class="comment"># 101,John Doe,CEO</span></span><br><span class="line"><span class="comment"># 102,Jason Smith,IT Manager</span></span><br><span class="line"><span class="comment"># 103,Raj Reddy,Sysadmin</span></span><br><span class="line"><span class="comment"># 104,Anand Ram,Developer</span></span><br><span class="line"><span class="comment"># 105,Jane Miller,Sales Manager</span></span><br><span class="line"></span><br><span class="line">awk -F, <span class="string">'/Manager/ &#123;print $2, $3&#125;'</span> employee.txt</span><br></pre></td></tr></table></figure>
<h3 id="awk变量、运算"><a href="#awk变量、运算" class="headerlink" title="awk变量、运算"></a>awk变量、运算</h3><p>一旦涉及变量定义这种比较复杂的功能，我就偏向于写awk脚本，然后<code>awk -f xx.awk somefile</code>这样来执行，常见的数学操作(+-*/%，++ –)都支持。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123;</span><br><span class="line">        FS=<span class="string">","</span>;</span><br><span class="line">        total=0;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$2</span> <span class="string">"'s salary is: "</span> <span class="variable">$4</span>;</span><br><span class="line">        total+=<span class="variable">$4</span>;</span><br><span class="line">&#125;</span><br><span class="line">END &#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="string">"----\nTotal Company Salary=$"</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="awk比较"><a href="#awk比较" class="headerlink" title="awk比较"></a>awk比较</h3><p>awk支持以下比较</p>
<p><img src="http://7xqlni.com1.z0.glb.clouddn.com/QQ截图20180403134602.png" alt="QQ截图20180403134602.png"></p>
<p>可以理解成sql中的where条件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk -F, <span class="string">'$5&lt;=5'</span> items.txt</span><br><span class="line">awk -F <span class="string">","</span> <span class="string">'$4 &lt; 900 || $5 &lt;= 5'</span> items.txt</span><br><span class="line">awk -F <span class="string">':'</span> <span class="string">'$3 &gt; maxuid &#123; maxuid = $3; maxline = $0 &#125; END &#123; print maxuid,maxline &#125;'</span> /etc/passwd</span><br><span class="line">awk -F <span class="string">':'</span> <span class="string">'$3 &gt;= 100 &amp;&amp; $NF ~ /\/bin\/sh/ '</span> /etc/passwd <span class="comment"># $NF 代表最后一列， ~表示正则匹配， !~也就是不匹配咯</span></span><br></pre></td></tr></table></figure></p>
<h3 id="awk控制流"><a href="#awk控制流" class="headerlink" title="awk控制流"></a>awk控制流</h3><p>awk支持if,if\else,while、do-while都常见控制流，for(;;)当然也不在话下，连break、continue、exit都有哦。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat dowhile.awk</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> i=2;</span><br><span class="line"> total=0;</span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line"> total = total + <span class="variable">$i</span>;</span><br><span class="line"> i++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span>(i&lt;=NF)</span><br><span class="line"><span class="built_in">print</span> <span class="string">"Item"</span>,<span class="variable">$1</span>,<span class="string">":"</span>,total,<span class="string">"quantities sold"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"1 2 3 4"</span> | awk <span class="string">'&#123; for (i=1;i&lt;=NF;i++) total = total + $i &#125; END &#123; print total &#125;'</span></span><br></pre></td></tr></table></figure>
<h3 id="awk关联数组"><a href="#awk关联数组" class="headerlink" title="awk关联数组"></a>awk关联数组</h3><p>没错，这个就是lua中的关联数组的概念</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ cat array-assign.awk</span><br><span class="line">BEGIN &#123;</span><br><span class="line"> item[101]=<span class="string">"HD Camcorder"</span>;</span><br><span class="line"> item[102]=<span class="string">"Refrigerator"</span>;</span><br><span class="line"> item[103]=<span class="string">"MP3 Player"</span>;</span><br><span class="line"> item[104]=<span class="string">"Tennis Racket"</span>;</span><br><span class="line"> item[105]=<span class="string">"Laser Printer"</span>;</span><br><span class="line"> item[1001]=<span class="string">"Tennis Ball"</span>;</span><br><span class="line"> item[55]=<span class="string">"Laptop"</span>;</span><br><span class="line"> item[<span class="string">"na"</span>]=<span class="string">"Not Available"</span>;</span><br><span class="line"> <span class="built_in">print</span> item[<span class="string">"101"</span>];</span><br><span class="line"> <span class="built_in">print</span> item[102];</span><br><span class="line"> <span class="built_in">print</span> item[<span class="string">"103"</span>];</span><br><span class="line"> <span class="built_in">print</span> item[104];</span><br><span class="line"> <span class="built_in">print</span> item[<span class="string">"105"</span>];</span><br><span class="line"> <span class="built_in">print</span> item[1001];</span><br><span class="line"> <span class="built_in">print</span> item[<span class="string">"na"</span>];</span><br><span class="line">&#125;</span><br><span class="line">$ awk -f array-assign.awk</span><br><span class="line">HD Camcorder</span><br><span class="line">Refrigerator</span><br><span class="line">MP3 Player</span><br><span class="line">Tennis Racket</span><br><span class="line">Laser Printer</span><br><span class="line">Tennis Ball</span><br><span class="line">Not Available</span><br></pre></td></tr></table></figure>
<p>数组遍历</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ cat array-for-loop.awk</span><br><span class="line">BEGIN &#123;</span><br><span class="line"> item[101]=<span class="string">"HD Camcorder"</span>;</span><br><span class="line"> item[102]=<span class="string">"Refrigerator"</span>;</span><br><span class="line"> item[103]=<span class="string">"MP3 Player"</span>;</span><br><span class="line"> item[104]=<span class="string">"Tennis Racket"</span>;</span><br><span class="line"> item[105]=<span class="string">"Laser Printer"</span>;</span><br><span class="line"> item[1001]=<span class="string">"Tennis Ball"</span>;</span><br><span class="line"> item[55]=<span class="string">"Laptop"</span>;</span><br><span class="line"> item[<span class="string">"no"</span>]=<span class="string">"Not Available"</span>;</span><br><span class="line"> <span class="keyword">for</span>(x <span class="keyword">in</span> item)</span><br><span class="line"> <span class="built_in">print</span> item[x]</span><br><span class="line">&#125;</span><br><span class="line">$ awk -f array-for-loop.awk</span><br><span class="line">Not Available</span><br><span class="line">Laptop</span><br><span class="line">HD Camcorder</span><br><span class="line">Refrigerator</span><br><span class="line">MP3 Player</span><br><span class="line">Tennis Racket</span><br><span class="line">Laser Printer</span><br><span class="line">Tennis Ball</span><br></pre></td></tr></table></figure>
<p>数组删除</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat array-delete.awk</span><br><span class="line">BEGIN &#123;</span><br><span class="line"> item[101]=<span class="string">"HD Camcorder"</span>;</span><br><span class="line"> item[102]=<span class="string">"Refrigerator"</span>;</span><br><span class="line"> item[103]=<span class="string">"MP3 Player"</span>;</span><br><span class="line"> item[104]=<span class="string">"Tennis Racket"</span>;</span><br><span class="line"> item[105]=<span class="string">"Laser Printer"</span>;</span><br><span class="line"> item[1001]=<span class="string">"Tennis Ball"</span>;</span><br><span class="line"> item[55]=<span class="string">"Laptop"</span>;</span><br><span class="line"> item[<span class="string">"no"</span>]=<span class="string">"Not Available"</span>;</span><br><span class="line"> delete item[102]</span><br><span class="line"> item[103]=<span class="string">""</span></span><br><span class="line"> delete item[104]</span><br><span class="line"> delete item[1001]</span><br><span class="line"> delete item[<span class="string">"na"</span>]</span><br><span class="line"> <span class="keyword">for</span>(x <span class="keyword">in</span> item)</span><br><span class="line"> <span class="built_in">print</span> <span class="string">"Index"</span>,x,<span class="string">"contains"</span>,item[x]</span><br><span class="line">&#125;</span><br><span class="line">$ awk -f array-delete.awk</span><br><span class="line">Index no contains Not Available</span><br><span class="line">Index 55 contains Laptop</span><br><span class="line">Index 101 contains HD Camcorder</span><br><span class="line">Index 103 contains</span><br><span class="line">Index 105 contains Laser Printer</span><br></pre></td></tr></table></figure>
<p>awk支持的功能还有很多，这里不一一介绍，总之，凡是文本数据处理，用awk就没错了！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.thegeekstuff.com/sed-awk-101-hacks-ebook/" target="_blank" rel="noopener">https://www.thegeekstuff.com/sed-awk-101-hacks-ebook/</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/awk/">awk</a><a href="/tags/linux/">linux</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/04/03/awk-like-a-boss/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/16/golang热更新的魔法/"><span>golang热更新的魔法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/16/golang热更新的魔法/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-16T02:21:03.000Z">
          2018-03-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>当我们写一个服务端程序的时候，在更新时可能不可避免的需要停止程序再重启，这里介绍一种非常酷的热更新实现，真正做到zero downtime。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>更换硬盘上的可执行程序</li>
<li>以相同的参数启动一个子进程，并把正在listen的fd传递给子进程</li>
<li>子进程通过这个fd进行listen，这样父子进程可以同时Accept连接</li>
<li>立马通知父进程停止接受连接，然后父进程gracefully shutdown </li>
</ol>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>POSIX提供了fork和exec调用来启动一个新进程，fork复制父进程，然后通过exec来替换自己要执行的程序。在go中，我们使用exec.Command或者os.StartProcess来达到类似效果。<br>在启动子进程时，需要让子进程知道，我正处于热更新过程中。通常使用环境变量或者参数来实现，例子中使用了-graceful这个参数。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">file := netListener.File() <span class="comment">// this returns a Dup()</span></span><br><span class="line">path := <span class="string">"/path/to/executable"</span></span><br><span class="line">args := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"-graceful"</span>&#125;</span><br><span class="line"></span><br><span class="line">cmd := exec.Command(path, args...)</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line">cmd.ExtraFiles = []*os.File&#123;file&#125;</span><br><span class="line"></span><br><span class="line">err := cmd.Start()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">"gracefulRestart: Failed to launch, error: %v"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在子进程中使用net.FileListener来从fd创建一个Listener</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func FileListener</span><br><span class="line">func FileListener(f *os.File) (ln Listener, err error)</span><br><span class="line">FileListener returns a copy of the network listener corresponding to the open file f. It is the caller&apos;s responsibility to close ln when finished. Closing ln does not affect f, and closing f does not affect ln.</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flag.BoolVar(&amp;gracefulChild, <span class="string">"graceful"</span>, <span class="literal">false</span>, <span class="string">"listen on fd open 3 (internal use only)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> gracefulChild &#123;</span><br><span class="line">    log.Print(<span class="string">"main: Listening to existing file descriptor 3."</span>)</span><br><span class="line">    f := os.NewFile(<span class="number">3</span>, <span class="string">""</span>) <span class="comment">// 3就是我们传递的listening fd</span></span><br><span class="line">    l, err = net.FileListener(f)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.Print(<span class="string">"main: Listening on a new file descriptor."</span>)</span><br><span class="line">    l, err = net.Listen(<span class="string">"tcp"</span>, server.Addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，子进程就可以Accept并接受连接了，现在我们还需要立刻干掉父进程。使用getpid调用获取到父进程的id，然后kill它。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent := syscall.Getppid()</span><br><span class="line">syscall.Kill(parent, syscall.SIGTERM)</span><br></pre></td></tr></table></figure>
<p>当然，更加完美的方式还需要父进程可以优雅退出，即不再接受新连接，并且处理完当前所有连接后再退出，如果一段时间内没能处理完，也可以选择直接退出。准备另写文章介绍这个内容。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://grisha.org/blog/2014/06/03/graceful-restart-in-golang" target="_blank" rel="noopener">http://grisha.org/blog/2014/06/03/graceful-restart-in-golang</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/03/16/golang热更新的魔法/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/11/goim中的数据结构/"><span>goim中的数据结构</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/11/goim中的数据结构/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-11T05:35:36.000Z">
          2018-03-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>goim中数据结构的设计非常出彩，值得仔细品味。</p>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>在长连接这样的场景下，有N条连接需要维护心跳信息，凡人的做法可能就是开启N个gorutine，但goim使用最小堆高效处理了这个问题。</p>
<p>Timer就是定时器的结构，对外提供Add、Del、Set三个方法用于添加，删除、修改TimerData。</p>
<p>TimerData存储单个定时器的信息，到期则执行回调函数fn。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libs/time/timer.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock   sync.Mutex</span><br><span class="line">	free   *TimerData</span><br><span class="line">	timers []*TimerData</span><br><span class="line">	signal *itime.Timer</span><br><span class="line">	num    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TimerData <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key    <span class="keyword">string</span></span><br><span class="line">	expire itime.Time</span><br><span class="line">	fn     <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	<span class="title">index</span>  <span class="title">int</span></span></span><br><span class="line"><span class="function">	<span class="title">next</span>   *<span class="title">TimerData</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>先看一下添加删除timer的逻辑</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libs/time/timer.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">Add</span><span class="params">(expire itime.Duration, fn <span class="keyword">func</span>()</span>) <span class="params">(td *TimerData)</span></span> &#123;</span><br><span class="line">	t.lock.Lock()</span><br><span class="line">	td = t.get()</span><br><span class="line">	td.expire = itime.Now().Add(expire)</span><br><span class="line">	td.fn = fn</span><br><span class="line">	t.add(td)</span><br><span class="line">	t.lock.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">Del</span><span class="params">(td *TimerData)</span></span> &#123;</span><br><span class="line">	t.lock.Lock()</span><br><span class="line">	t.del(td)</span><br><span class="line">	t.put(td)</span><br><span class="line">	t.lock.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">Set</span><span class="params">(td *TimerData, expire itime.Duration)</span></span> &#123;</span><br><span class="line">	t.lock.Lock()</span><br><span class="line">	t.del(td)</span><br><span class="line">	td.expire = itime.Now().Add(expire)</span><br><span class="line">	t.add(td)</span><br><span class="line">	t.lock.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除去加锁部分，内部就是调用了add、、del、get、put这几个方法。</p>
<p>get和put非常简单，只是根据当前的free指针获得或者放回去一个TimerData。</p>
<p>add和del是典型的堆操作，就是往timers这个堆里添加删除元素。</p>
<p>Timer在初始化时就会构造好一条free链表，在Add时，先取出free指向的节点，加入到timers堆中。在Del时，先从堆中删除，再放回链表中。</p>
<p>这条free链表是为了避免频繁申请内存做的优化！get和put负责在链表中申请和释放节点，add和del在获取到节点(TimerData)后进行堆的调整！</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libs/time/timer.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get get a free timer data.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">get</span><span class="params">()</span> <span class="params">(td *TimerData)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> td = t.free; td == <span class="literal">nil</span> &#123;</span><br><span class="line">		t.grow()</span><br><span class="line">		td = t.free</span><br><span class="line">	&#125;</span><br><span class="line">	t.free = td.next</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// put put back a timer data.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">put</span><span class="params">(td *TimerData)</span></span> &#123;</span><br><span class="line">	td.fn = <span class="literal">nil</span></span><br><span class="line">	td.next = t.free</span><br><span class="line">	t.free = td</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push pushes the element x onto the heap. The complexity is</span></span><br><span class="line"><span class="comment">// O(log(n)) where n = h.Len().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">add</span><span class="params">(td *TimerData)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> d itime.Duration</span><br><span class="line">	td.index = <span class="built_in">len</span>(t.timers)</span><br><span class="line">	<span class="comment">// add to the minheap last node</span></span><br><span class="line">	t.timers = <span class="built_in">append</span>(t.timers, td)</span><br><span class="line">	t.up(td.index)</span><br><span class="line">	<span class="keyword">if</span> td.index == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// if first node, signal start goroutine</span></span><br><span class="line">		d = td.Delay()</span><br><span class="line">		t.signal.Reset(d)</span><br><span class="line">		<span class="keyword">if</span> Debug &#123;</span><br><span class="line">			log.Debug(<span class="string">"timer: add reset delay %d ms"</span>, <span class="keyword">int64</span>(d)/<span class="keyword">int64</span>(itime.Millisecond))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> Debug &#123;</span><br><span class="line">		log.Debug(<span class="string">"timer: push item key: %s, expire: %s, index: %d"</span>, td.Key, td.ExpireString(), td.index)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">del</span><span class="params">(td *TimerData)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		i    = td.index</span><br><span class="line">		last = <span class="built_in">len</span>(t.timers) - <span class="number">1</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt; last || t.timers[i] != td &#123;</span><br><span class="line">		<span class="comment">// already remove, usually by expire</span></span><br><span class="line">		<span class="keyword">if</span> Debug &#123;</span><br><span class="line">			log.Debug(<span class="string">"timer del i: %d, last: %d, %p"</span>, i, last, td)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> i != last &#123;</span><br><span class="line">		t.swap(i, last)</span><br><span class="line">		t.down(i, last)</span><br><span class="line">		t.up(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// remove item is the last node</span></span><br><span class="line">	t.timers[last].index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">	t.timers = t.timers[:last]</span><br><span class="line">	<span class="keyword">if</span> Debug &#123;</span><br><span class="line">		log.Debug(<span class="string">"timer: remove item key: %s, expire: %s, index: %d"</span>, td.Key, td.ExpireString(), td.index)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，timer定时这块是怎么实现的呢？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">init</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	t.signal = itime.NewTimer(infiniteDuration)</span><br><span class="line">	t.timers = <span class="built_in">make</span>([]*TimerData, <span class="number">0</span>, num)</span><br><span class="line">	t.num = num</span><br><span class="line">	t.grow()</span><br><span class="line">	<span class="keyword">go</span> t.start() <span class="comment">// 此处开始轮询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，只启动了一个gorutine来管理所有的timer,start内部是一个无限循环，expire()负责设置一个最近的定期器，然后阻塞等待即可。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		t.expire()</span><br><span class="line">		&lt;-t.signal.C</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">expire</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		<span class="title">td</span> *<span class="title">TimerData</span></span></span><br><span class="line"><span class="function">		<span class="title">d</span>  <span class="title">itime</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function">	)</span></span><br><span class="line"><span class="function">	<span class="title">t</span>.<span class="title">lock</span>.<span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	<span class="title">for</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(t.timers) == <span class="number">0</span> &#123; <span class="comment">// 没有定时器，无限睡眠</span></span><br><span class="line">			d = infiniteDuration</span><br><span class="line">			<span class="keyword">if</span> Debug &#123;</span><br><span class="line">				log.Debug(<span class="string">"timer: no other instance"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		td = t.timers[<span class="number">0</span>] <span class="comment">// 取第一个元素，如何还没到期就根据剩余时间重置定时器</span></span><br><span class="line">		<span class="keyword">if</span> d = td.Delay(); d &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fn = td.fn</span><br><span class="line">		<span class="comment">// let caller put back, usually by Del()</span></span><br><span class="line">		t.del(td) <span class="comment">// 从堆中删除</span></span><br><span class="line">		t.lock.Unlock()</span><br><span class="line">		<span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Warn(<span class="string">"expire timer no fn"</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> Debug &#123;</span><br><span class="line">				log.Debug(<span class="string">"timer key: %s, expire: %s, index: %d expired, call fn"</span>, td.Key, td.ExpireString(), td.index)</span><br><span class="line">			&#125;</span><br><span class="line">			fn() <span class="comment">// 执行回调</span></span><br><span class="line">		&#125;</span><br><span class="line">		t.lock.Lock()</span><br><span class="line">	&#125;</span><br><span class="line">	t.signal.Reset(d)</span><br><span class="line">	<span class="keyword">if</span> Debug &#123;</span><br><span class="line">		log.Debug(<span class="string">"timer: expire reset delay %d ms"</span>, <span class="keyword">int64</span>(d)/<span class="keyword">int64</span>(itime.Millisecond))</span><br><span class="line">	&#125;</span><br><span class="line">	t.lock.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h3><p>Pool可以理解成内存，free是空闲内存的指针，Buffer是内存分配的基本单元<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock sync.Mutex</span><br><span class="line">	free *Buffer</span><br><span class="line">	max  <span class="keyword">int</span></span><br><span class="line">	num  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Buffer <span class="keyword">struct</span> &#123;</span><br><span class="line">	buf  []<span class="keyword">byte</span></span><br><span class="line">	next *Buffer <span class="comment">// next free buffer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Pool初始化时，会申请一块很大的buf，然后构建Buffer链表，每个Buffer都通过slice指向这个buf的一部分。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">grow</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		i   <span class="keyword">int</span></span><br><span class="line">		b   *Buffer</span><br><span class="line">		bs  []Buffer</span><br><span class="line">		buf []<span class="keyword">byte</span></span><br><span class="line">	)</span><br><span class="line">	buf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, p.max)</span><br><span class="line">	bs = <span class="built_in">make</span>([]Buffer, p.num)</span><br><span class="line">	p.free = &amp;bs[<span class="number">0</span>]</span><br><span class="line">	b = p.free</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span>; i &lt; p.num; i++ &#123;</span><br><span class="line">		b.buf = buf[(i<span class="number">-1</span>)*p.size : i*p.size]</span><br><span class="line">		b.next = &amp;bs[i]</span><br><span class="line">		b = b.next</span><br><span class="line">	&#125;</span><br><span class="line">	b.buf = buf[(i<span class="number">-1</span>)*p.size : i*p.size]</span><br><span class="line">	b.next = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，申请和释放Buffer只需要操作链表的指针即可，复杂度O（1）</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get get a free memory buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(b *Buffer)</span></span> &#123;</span><br><span class="line">	p.lock.Lock()</span><br><span class="line">	<span class="keyword">if</span> b = p.free; b == <span class="literal">nil</span> &#123;</span><br><span class="line">		p.grow()</span><br><span class="line">		b = p.free</span><br><span class="line">	&#125;</span><br><span class="line">	p.free = b.next</span><br><span class="line">	p.lock.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Put put back a memory buffer to free.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(b *Buffer)</span></span> &#123;</span><br><span class="line">	p.lock.Lock()</span><br><span class="line">	b.next = p.free</span><br><span class="line">	p.free = b</span><br><span class="line">	p.lock.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Router模块中的Cleaner"><a href="#Router模块中的Cleaner" class="headerlink" title="Router模块中的Cleaner"></a>Router模块中的Cleaner</h3><p>Cleaner中主要使用了一条双向循环链表，但额外设计了一个map，来提供快速的节点定位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">type CleanData struct &#123;</span><br><span class="line">	Key        int64</span><br><span class="line">	expireTime time.Time</span><br><span class="line">	next, prev *CleanData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Cleaner struct &#123;</span><br><span class="line">	cLock sync.Mutex</span><br><span class="line">	size  int</span><br><span class="line">	root  CleanData</span><br><span class="line">	maps  map[int64]*CleanData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Cleaner) PushFront(key int64, expire time.Duration) &#123;</span><br><span class="line">	c.cLock.Lock()</span><br><span class="line">	if e, ok := c.maps[key]; ok &#123;</span><br><span class="line">		// update time</span><br><span class="line">		e.expireTime = time.Now().Add(expire)</span><br><span class="line">		c.moveToFront(e)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		e = new(CleanData)</span><br><span class="line">		e.Key = key</span><br><span class="line">		e.expireTime = time.Now().Add(expire)</span><br><span class="line">		c.maps[key] = e</span><br><span class="line">		at := &amp;c.root</span><br><span class="line">		n := at.next</span><br><span class="line">		at.next = e</span><br><span class="line">		e.prev = at</span><br><span class="line">		e.next = n</span><br><span class="line">		n.prev = e</span><br><span class="line">		c.size++</span><br><span class="line">	&#125;</span><br><span class="line">	c.cLock.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Comet模块中的RingBuf"><a href="#Comet模块中的RingBuf" class="headerlink" title="Comet模块中的RingBuf"></a>Comet模块中的RingBuf</h3><p>RingBuf是一个环形缓冲区，其中保存的是空闲的proto对象，负责TCP数据的拆包封包。每个连接都会初始化自己的RingBuf。</p>
<p>值得一提的是，RingBuf使用<code>sequence &amp; （array length－1） = array index</code>这样的方式来定位元素,非常高效。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ring <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    rp   <span class="keyword">uint64</span></span><br><span class="line">    num  <span class="keyword">uint64</span></span><br><span class="line">    mask <span class="keyword">uint64</span></span><br><span class="line">    <span class="comment">// TODO split cacheline, many cpu cache line size is 64</span></span><br><span class="line">    <span class="comment">// pad [40]byte</span></span><br><span class="line">    <span class="comment">// write</span></span><br><span class="line">    wp   <span class="keyword">uint64</span></span><br><span class="line">    data []proto.Proto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRing</span><span class="params">(num <span class="keyword">int</span>)</span> *<span class="title">Ring</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">new</span>(Ring)</span><br><span class="line">    r.init(<span class="keyword">uint64</span>(num))</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Init</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    r.init(<span class="keyword">uint64</span>(num))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">init</span><span class="params">(num <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 2^N</span></span><br><span class="line">    <span class="keyword">if</span> num&amp;(num<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> num&amp;(num<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">            num &amp;= (num - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        num = num &lt;&lt; <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    r.data = <span class="built_in">make</span>([]proto.Proto, num)</span><br><span class="line">    r.num = num</span><br><span class="line">    r.mask = r.num - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(proto *proto.Proto, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.rp == r.wp &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrRingEmpty</span><br><span class="line">    &#125;</span><br><span class="line">    proto = &amp;r.data[r.rp&amp;r.mask]</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">GetAdv</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r.rp++</span><br><span class="line">    <span class="keyword">if</span> Debug &#123;</span><br><span class="line">        log.Debug(<span class="string">"ring rp: %d, idx: %d"</span>, r.rp, r.rp&amp;r.mask)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Set</span><span class="params">()</span> <span class="params">(proto *proto.Proto, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.wp-r.rp &gt;= r.num &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrRingFull</span><br><span class="line">    &#125;</span><br><span class="line">    proto = &amp;r.data[r.wp&amp;r.mask]</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">SetAdv</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r.wp++</span><br><span class="line">    <span class="keyword">if</span> Debug &#123;</span><br><span class="line">        log.Debug(<span class="string">"ring wp: %d, idx: %d"</span>, r.wp, r.wp&amp;r.mask)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Ring)</span> <span class="title">Reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r.rp = <span class="number">0</span></span><br><span class="line">    r.wp = <span class="number">0</span></span><br><span class="line">    <span class="comment">// prevent pad compiler optimization</span></span><br><span class="line">    <span class="comment">// r.pad = [40]byte&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://ifeve.com/dissecting-disruptor-whats-so-special/" target="_blank" rel="noopener">http://ifeve.com/dissecting-disruptor-whats-so-special/</a><br><a href="https://github.com/Terry-Mao/goim" target="_blank" rel="noopener">https://github.com/Terry-Mao/goim</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/goim源码分析/">goim源码分析</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/03/11/goim中的数据结构/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/09/goim-comet模块源码分析/"><span>goim-comet模块源码分析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/09/goim-comet模块源码分析/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-09T02:04:31.000Z">
          2018-03-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>comet是客户端直接连接的节点，设计上是无状态的。通过rpc与logic服务交互，对外提供TCP、HTTP、WebSocket连接方式，自己也作为push这个rpc服务的提供方</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.go</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := InitLogicRpc(Conf.LogicAddrs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Warn(<span class="string">"logic rpc current can't connect, retry"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// start monitor</span></span><br><span class="line">    <span class="keyword">if</span> Conf.MonitorOpen &#123;</span><br><span class="line">        InitMonitor(Conf.MonitorAddrs)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">//bucket round server的初始化，下面会讲</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// white list</span></span><br><span class="line">    <span class="comment">// tcp comet</span></span><br><span class="line">    <span class="keyword">if</span> err := InitTCP(Conf.TCPBind, Conf.MaxProc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// websocket comet</span></span><br><span class="line">    <span class="keyword">if</span> err := InitWebsocket(Conf.WebsocketBind); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// flash safe policy</span></span><br><span class="line">    <span class="keyword">if</span> Conf.FlashPolicyOpen &#123;</span><br><span class="line">        <span class="keyword">if</span> err := InitFlashPolicy(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wss comet</span></span><br><span class="line">    <span class="keyword">if</span> Conf.WebsocketTLSOpen &#123;</span><br><span class="line">        <span class="keyword">if</span> err := InitWebsocketWithTLS(Conf.WebsocketTLSBind, Conf.WebsocketCertFile, Conf.WebsocketPrivateFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// start rpc</span></span><br><span class="line">    <span class="keyword">if</span> err := InitRPCPush(Conf.RPCPushAddrs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="InitTCP"><a href="#InitTCP" class="headerlink" title="InitTCP"></a>InitTCP</h2><p>InitXXX的作用是暴露不同的服务给客户端使用，选一个看就可以了。</p>
<p>在多个gorutine中调用了AcceptTCP，充分发挥多核能力<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; accept; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> acceptTCP(DefaultServer, listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>accept之后，核心逻辑实现在serveTCP中,首先调用auth服务，获得subKey,然后把channel放进bucket里</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="keyword">if</span> p, err = ch.CliProto.Set(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> key, ch.RoomId, hb, err = server.authTCP(rr, wr, p); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        b = server.Bucket(key)</span><br><span class="line">        err = b.Put(key, ch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>serveTCP方法中，当前gorutine负责读数据，处理心跳，把数据封装成proto对象然后保存到channel的CliProto中，然后通知dispatchTCP处理<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p, err = ch.CliProto.Set(); err != <span class="literal">nil</span> &#123; <span class="comment">// 从channel中申请一个buffer用来存放proto</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> white &#123;</span><br><span class="line">            DefaultWhitelist.Log.Printf(<span class="string">"key: %s start read proto\n"</span>, key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err = p.ReadTCP(rr); err != <span class="literal">nil</span> &#123; <span class="comment">// 读proto</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> white &#123;</span><br><span class="line">            DefaultWhitelist.Log.Printf(<span class="string">"key: %s read proto:%v\n"</span>, key, p)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p.Operation == define.OP_HEARTBEAT &#123; <span class="comment">// 维持心跳</span></span><br><span class="line">            tr.Set(trd, hb)</span><br><span class="line">            p.Body = <span class="literal">nil</span></span><br><span class="line">            p.Operation = define.OP_HEARTBEAT_REPLY</span><br><span class="line">            <span class="keyword">if</span> Debug &#123;</span><br><span class="line">                log.Debug(<span class="string">"key: %s receive heartbeat"</span>, key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err = server.operator.Operate(p); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> white &#123;</span><br><span class="line">            DefaultWhitelist.Log.Printf(<span class="string">"key: %s process proto:%v\n"</span>, key, p)</span><br><span class="line">        &#125;</span><br><span class="line">        ch.CliProto.SetAdv()</span><br><span class="line">        ch.Signal() <span class="comment">//通知dispatchTCP处理</span></span><br><span class="line">        <span class="keyword">if</span> white &#123;</span><br><span class="line">            DefaultWhitelist.Log.Printf(<span class="string">"key: %s signal\n"</span>, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>dispatchTCP中，如果收到proto.ProtoReady，就表示读取到了一个proto，然后原样写回？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> proto.ProtoReady:</span><br><span class="line">    <span class="comment">// fetch message from svrbox(client send)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p, err = ch.CliProto.Get(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = <span class="literal">nil</span> <span class="comment">// must be empty error</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> white &#123;</span><br><span class="line">            DefaultWhitelist.Log.Printf(<span class="string">"key: %s start write client proto%v\n"</span>, key, p)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err = p.WriteTCP(wr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> failed</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> white &#123;</span><br><span class="line">            DefaultWhitelist.Log.Printf(<span class="string">"key: %s write client proto%v\n"</span>, key, p)</span><br><span class="line">        &#125;</span><br><span class="line">        p.Body = <span class="literal">nil</span> <span class="comment">// avoid memory leak</span></span><br><span class="line">        ch.CliProto.GetAdv()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Round"><a href="#Round" class="headerlink" title="Round"></a>Round</h3><p>goim自己进行了buffer的管理，避免了频繁申请内存的开销。通过自定义的Pool结构来分配Buffer，因为分配时要加锁，使用Round来组合多个Pool，通过mod运算随机获取一个Pool，来减缓锁的争用。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// round.go</span></span><br><span class="line"><span class="comment">// Reader get a reader memory buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Round)</span> <span class="title">Reader</span><span class="params">(rn <span class="keyword">int</span>)</span> *<span class="title">bytes</span>.<span class="title">Pool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(r.readers[rn%r.options.Reader])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer get a writer memory buffer pool.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Round)</span> <span class="title">Writer</span><span class="params">(rn <span class="keyword">int</span>)</span> *<span class="title">bytes</span>.<span class="title">Pool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(r.writers[rn%r.options.Writer])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pool内部使用一条单链表，维护一个free指针指向未分配的buffer</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libs/buffer.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">grow</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        i   <span class="keyword">int</span></span><br><span class="line">        b   *Buffer</span><br><span class="line">        bs  []Buffer</span><br><span class="line">        buf []<span class="keyword">byte</span></span><br><span class="line">    )</span><br><span class="line">    buf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, p.max) <span class="comment">// 所有的Buffer都从这里分配</span></span><br><span class="line">    bs = <span class="built_in">make</span>([]Buffer, p.num) <span class="comment">// Buffer数组</span></span><br><span class="line">    p.free = &amp;bs[<span class="number">0</span>] <span class="comment">//构造Buffer链</span></span><br><span class="line">    b = p.free</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>; i &lt; p.num; i++ &#123;</span><br><span class="line">        b.buf = buf[(i<span class="number">-1</span>)*p.size : i*p.size]</span><br><span class="line">        b.next = &amp;bs[i]</span><br><span class="line">        b = b.next</span><br><span class="line">    &#125;</span><br><span class="line">    b.buf = buf[(i<span class="number">-1</span>)*p.size : i*p.size]</span><br><span class="line">    b.next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get get a free memory buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(b *Buffer)</span></span> &#123;</span><br><span class="line">    p.lock.Lock()</span><br><span class="line">    <span class="keyword">if</span> b = p.free; b == <span class="literal">nil</span> &#123;</span><br><span class="line">        p.grow()</span><br><span class="line">        b = p.free</span><br><span class="line">    &#125;</span><br><span class="line">    p.free = b.next</span><br><span class="line">    p.lock.Unlock()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>goim的Timer也是基于堆结构改写的，内部只有一个timer，不断把定时器设置成堆顶元素的触发时间来提高效率。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>TCP连接会被封装到Channel这个结构中，使用CliProto来处理封包拆包</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Channel <span class="keyword">struct</span> &#123;</span><br><span class="line">    RoomId   <span class="keyword">int32</span></span><br><span class="line">    CliProto Ring</span><br><span class="line">    signal   <span class="keyword">chan</span> *proto.Proto</span><br><span class="line">    Writer   bufio.Writer</span><br><span class="line">    Reader   bufio.Reader</span><br><span class="line">    Next     *Channel</span><br><span class="line">    Prev     *Channel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Ring"><a href="#Ring" class="headerlink" title="Ring"></a>Ring</h4><p>Ring是Channel内部用来保存并重用proto的一个结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Ring struct &#123;</span><br><span class="line">    // read</span><br><span class="line">    rp   uint64</span><br><span class="line">    num  uint64</span><br><span class="line">    mask uint64</span><br><span class="line">    // TODO split cacheline, many cpu cache line size is 64</span><br><span class="line">    // pad [40]byte</span><br><span class="line">    // write</span><br><span class="line">    wp   uint64</span><br><span class="line">    data []proto.Proto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Bucket"><a href="#Bucket" class="headerlink" title="Bucket"></a>Bucket</h3><p>bucket是channel的容器<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.go</span></span><br><span class="line"></span><br><span class="line">    buckets := <span class="built_in">make</span>([]*Bucket, Conf.Bucket)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; Conf.Bucket; i++ &#123;</span><br><span class="line">        buckets[i] = NewBucket(BucketOptions&#123;</span><br><span class="line">            ChannelSize:   Conf.BucketChannel,</span><br><span class="line">            RoomSize:      Conf.BucketRoom,</span><br><span class="line">            RoutineAmount: Conf.RoutineAmount,</span><br><span class="line">            RoutineSize:   Conf.RoutineSize,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/goim源码分析/">goim源码分析</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/03/09/goim-comet模块源码分析/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/07/goim-router模块源码分析/"><span>goim-router模块源码分析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/07/goim-router模块源码分析/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-07T08:17:13.000Z">
          2018-03-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>这个模块是用于保存状态信息的(例如在线的session)</p>
<p>文档里是这样描述的<br>router 属于有状态节点，logic可以使用一致性hash配置节点，增加多个router节点（目前还不支持动态扩容），提前预估好在线和压力情况</p>
<p>从main.go入手</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="keyword">if</span> err := InitConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    runtime.GOMAXPROCS(Conf.MaxProc)</span><br><span class="line">    log.LoadConfiguration(Conf.Log)</span><br><span class="line">    <span class="keyword">defer</span> log.Close()</span><br><span class="line">    log.Info(<span class="string">"router[%s] start"</span>, VERSION)</span><br><span class="line">    <span class="comment">// start prof</span></span><br><span class="line">    perf.Init(Conf.PprofAddrs)</span><br><span class="line">    <span class="comment">// start monitor</span></span><br><span class="line">    <span class="keyword">if</span> Conf.MonitorOpen &#123;</span><br><span class="line">        InitMonitor(Conf.MonitorAddrs)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// start rpc</span></span><br><span class="line">    buckets := <span class="built_in">make</span>([]*Bucket, Conf.Bucket)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; Conf.Bucket; i++ &#123;</span><br><span class="line">        buckets[i] = NewBucket(Conf.Session, Conf.Server, Conf.Cleaner)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := InitRPC(buckets); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// block until a signal is received.</span></span><br><span class="line">    InitSignal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>忽略flag和config部分的处理，这里主要涉及了<strong>perf</strong>，<strong>monitor</strong>监控，主<strong>RPC</strong>逻辑,以及<strong>signal</strong>处理</p>
<h3 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h3><p>内部使用了net/http/pprof进行性能分析</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(pprofBind []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    pprofServeMux := http.NewServeMux()</span><br><span class="line">    pprofServeMux.HandleFunc(<span class="string">"/debug/pprof/"</span>, pprof.Index)</span><br><span class="line">    pprofServeMux.HandleFunc(<span class="string">"/debug/pprof/cmdline"</span>, pprof.Cmdline)</span><br><span class="line">    pprofServeMux.HandleFunc(<span class="string">"/debug/pprof/profile"</span>, pprof.Profile)</span><br><span class="line">    pprofServeMux.HandleFunc(<span class="string">"/debug/pprof/symbol"</span>, pprof.Symbol)</span><br><span class="line">    <span class="keyword">for</span> _, addr := <span class="keyword">range</span> pprofBind &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := http.ListenAndServe(addr, pprofServeMux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Error(<span class="string">"http.ListenAndServe(\"%s\", pprofServeMux) error(%v)"</span>, addr, err)</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p>是一个简单ping请求处理,一看就是用来监测服务存活状态的</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitMonitor</span><span class="params">(binds []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">new</span>(Monitor)</span><br><span class="line">    monitorServeMux := http.NewServeMux()</span><br><span class="line">    monitorServeMux.HandleFunc(<span class="string">"/monitor/ping"</span>, m.Ping)</span><br><span class="line">    <span class="keyword">for</span> _, addr := <span class="keyword">range</span> binds &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(bind <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := http.ListenAndServe(bind, monitorServeMux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Error(<span class="string">"http.ListenAndServe(\"%s\", pprofServeMux) error(%v)"</span>, addr, err)</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(addr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// monitor ping</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Monitor)</span> <span class="title">Ping</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"ok"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p>信号处理，收到SIGHUP重载配置，这是符合linux上惯用约定的</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitSignal</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    signal.Notify(c, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT, syscall.SIGSTOP)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        s := &lt;-c</span><br><span class="line">        log.Info(<span class="string">"router[%s] get a signal %s"</span>, VERSION, s.String())</span><br><span class="line">        <span class="keyword">switch</span> s &#123;</span><br><span class="line">        <span class="keyword">case</span> syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGSTOP, syscall.SIGINT:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> syscall.SIGHUP:</span><br><span class="line">            reload()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reload</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newConf, err := ReloadConfig()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Error(<span class="string">"ReloadConfig() error(%v)"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    Conf = newConf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主RPC逻辑"><a href="#主RPC逻辑" class="headerlink" title="主RPC逻辑"></a>主RPC逻辑</h2><p>这里有Session、Cleaner、Bucket这三个主要的结构</p>
<p>Bucket是Session的容器，为了减少锁争夺，会有多个Bucket，根据用户id与Bucket数量进行mod运算来确定，这个Session放到哪个Bucket中，是一种很常见的sharding</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rpc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RouterRPC)</span> <span class="title">bucket</span><span class="params">(userId <span class="keyword">int64</span>)</span> *<span class="title">Bucket</span></span> &#123;</span><br><span class="line">    idx := <span class="keyword">int</span>(userId % r.BucketIdx) <span class="comment">// mod</span></span><br><span class="line">    <span class="comment">// fix panic</span></span><br><span class="line">    <span class="keyword">if</span> idx &lt; <span class="number">0</span> &#123;</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r.Buckets[idx]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RouterRPC)</span> <span class="title">Put</span><span class="params">(arg *proto.PutArg, reply *proto.PutReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    reply.Seq = r.bucket(arg.UserId).Put(arg.UserId, arg.Server, arg.RoomId)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucket.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">Put</span><span class="params">(userId <span class="keyword">int64</span>, server <span class="keyword">int32</span>, roomId <span class="keyword">int32</span>)</span> <span class="params">(seq <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        s  *Session</span><br><span class="line">        ok <span class="keyword">bool</span></span><br><span class="line">    )</span><br><span class="line">    b.bLock.Lock() <span class="comment">//加锁，只影响这个Bucket</span></span><br><span class="line">    <span class="keyword">if</span> s, ok = b.sessions[userId]; !ok &#123;</span><br><span class="line">        s = NewSession(b.server)</span><br><span class="line">        b.sessions[userId] = s</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> roomId != define.NoRoom &#123;</span><br><span class="line">        seq = s.PutRoom(server, roomId)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        seq = s.Put(server)</span><br><span class="line">    &#125;</span><br><span class="line">    b.counter(userId, server, roomId, <span class="literal">true</span>)</span><br><span class="line">    b.bLock.Unlock()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cleaner是与Session一一对应的一个结构，用于清理Session信息,每个Bucket会有一个单独的gorutine进行定时清理</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bucket.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBucket</span><span class="params">(session, server, cleaner <span class="keyword">int</span>)</span> *<span class="title">Bucket</span></span> &#123;</span><br><span class="line">    b := <span class="built_in">new</span>(Bucket)</span><br><span class="line">    b.sessions = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]*Session, session)</span><br><span class="line">    b.roomCounter = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">int32</span>)</span><br><span class="line">    b.serverCounter = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">int32</span>)</span><br><span class="line">    b.userServerCounter = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int32</span>)</span><br><span class="line">    b.cleaner = NewCleaner(cleaner)</span><br><span class="line">    b.server = server</span><br><span class="line">    b.session = session</span><br><span class="line">    <span class="keyword">go</span> b.clean() <span class="comment">//启动清理gorutine</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bucket)</span> <span class="title">clean</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        i       <span class="keyword">int</span></span><br><span class="line">        userIds []<span class="keyword">int64</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        userIds = b.cleaner.Clean()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(userIds) != <span class="number">0</span> &#123;</span><br><span class="line">            b.bLock.Lock()</span><br><span class="line">            <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(userIds); i++ &#123;</span><br><span class="line">                b.delEmpty(userIds[i]) 从sessions <span class="keyword">map</span>中删掉对应的session</span><br><span class="line">            &#125;</span><br><span class="line">            b.bLock.Unlock()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(Conf.BucketCleanPeriod) <span class="comment">//休息一段时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cleaner本身的结构是经过精心设计的，使用了一条双向循环链表来记录当前所有Session的信息，为了克服移除一个节点时需要遍历链表，额外用了一个map来快速定位到节点，然后操作这个节点的指针来进行删除</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cleaner)</span> <span class="title">remove</span><span class="params">(key <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e, ok := c.maps[key]; ok &#123; <span class="comment">//通过map定位</span></span><br><span class="line">        <span class="built_in">delete</span>(c.maps, key) <span class="comment">// 从map中删除</span></span><br><span class="line">        <span class="comment">// 从链表中删除</span></span><br><span class="line">        e.prev.next = e.next</span><br><span class="line">        e.next.prev = e.prev</span><br><span class="line">        e.next = <span class="literal">nil</span> <span class="comment">// avoid memory leaks</span></span><br><span class="line">        e.prev = <span class="literal">nil</span> <span class="comment">// avoid memory leaks</span></span><br><span class="line">        c.size--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cleaner)</span> <span class="title">Clean</span><span class="params">()</span> <span class="params">(keys []<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        i <span class="keyword">int</span></span><br><span class="line">        e *CleanData</span><br><span class="line">    )</span><br><span class="line">    keys = <span class="built_in">make</span>([]<span class="keyword">int64</span>, <span class="number">0</span>, maxCleanNum)</span><br><span class="line">    c.cLock.Lock()</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; maxCleanNum; i++ &#123; <span class="comment">// 每次最多只清理maxCleanNum个节点，don't know why</span></span><br><span class="line">        <span class="keyword">if</span> e = c.back(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> e.expire() &#123;</span><br><span class="line">                c.remove(e.Key)</span><br><span class="line">                keys = <span class="built_in">append</span>(keys, e.Key)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// next time</span></span><br><span class="line">    c.cLock.Unlock()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个问题是，没有看懂过期的逻辑。从链表尾部开始清理，却在Del时把节点放到头部？</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/goim源码分析/">goim源码分析</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/03/07/goim-router模块源码分析/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/01/使用influxdb构建运营数据Metrics系统/"><span>使用influxdb收集用户行为数据</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/01/使用influxdb构建运营数据Metrics系统/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-01T06:25:40.000Z">
          2018-03-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>目前我们需要收集一些用户在站点上的行为数据，又不想投入精力研发一整套的体系，于是找到了influxdb。</p>
<p>influxdb内置了HTTP API,免去了编写接入代码的繁琐，并带有数据查询和展示的组件，非常适合。</p>
<p>安装过程略去不提，参考<a href="https://docs.influxdata.com/influxdb/v1.4/introduction/getting_started/" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>Influxdb</li>
<li>Chronograf</li>
<li>例子</li>
</ul>
<h2 id="Influxdb"><a href="#Influxdb" class="headerlink" title="Influxdb"></a>Influxdb</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一条influxdb的记录的结构是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;measurement&gt;[,&lt;tag-key&gt;=&lt;tag-value&gt;...] &lt;field-key&gt;=&lt;field-value&gt;[,&lt;field2-key&gt;=&lt;field2-value&gt;...] [unix-nano-timestamp]</span><br><span class="line"></span><br><span class="line">例如</span><br><span class="line"></span><br><span class="line">cpu,host=serverA,region=us_west value=0.64</span><br><span class="line">payment,device=mobile,product=Notepad,method=credit billed=33,licenses=3i 1434067467100293230</span><br><span class="line">stock,symbol=AAPL bid=127.46,ask=127.48</span><br><span class="line">temperature,machine=unit42,type=assembly external=25,internal=37 1434067467000000000</span><br></pre></td></tr></table></figure>
<p>类比于RDMBS</p>
<table>
<thead>
<tr>
<th>influxdb</th>
<th>rdbms</th>
</tr>
</thead>
<tbody>
<tr>
<td>unix-nano-timestamp</td>
<td>primary key</td>
</tr>
<tr>
<td>measurement</td>
<td>table</td>
</tr>
<tr>
<td>tag</td>
<td>indexed column</td>
</tr>
<tr>
<td>fields</td>
<td>column</td>
</tr>
</tbody>
</table>
<h3 id="HTTP-API"><a href="#HTTP-API" class="headerlink" title="HTTP API"></a>HTTP API</h3><p>influxdb的所有操作都可以通过HTTP API来完成</p>
<p><a href="https://docs.influxdata.com/influxdb/v1.4/guides/writing_data/" target="_blank" rel="noopener">写数据</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XPOST &apos;http://localhost:8086/write?db=mydb&apos; --data-binary &apos;cpu_load_short,host=server01,region=us-west value=0.64 1434055562000000000&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="Authentication-amp-Authorization"><a href="#Authentication-amp-Authorization" class="headerlink" title="Authentication &amp; Authorization"></a>Authentication &amp; Authorization</h3><p>通过HTTP API可以进行DDL操作，我们需要有一些<a href="https://docs.influxdata.com/influxdb/v1.4/query_language/authentication_and_authorization/#authorization" target="_blank" rel="noopener">权限机制</a>来保证安全.</p>
<ol>
<li>修改配置文件<strong>/etc/influxdb/influxdb.conf</strong>并重启</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[http]</span><br><span class="line">  ...</span><br><span class="line">  auth-enabled = true</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<ol>
<li>创建用户</li>
</ol>
<p>创建超级用户admin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER admin WITH PASSWORD &apos;123456&apos; WITH ALL PRIVILEGES</span><br></pre></td></tr></table></figure>
<p>创建普通用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER reader WITH PASSWORD &apos;123456&apos;</span><br><span class="line">GRANT READ ON &quot;mydb&quot; TO &quot;reader&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Rentention-Policy"><a href="#Rentention-Policy" class="headerlink" title="Rentention Policy"></a>Rentention Policy</h3><p>时序数据的量可能会非常大，需要定义保存数据的<a href="https://docs.influxdata.com/influxdb/v1.4/query_language/database_management/#retention-policy-management" target="_blank" rel="noopener">策略</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE RETENTION POLICY &quot;one_day_only&quot; ON &quot;mydb&quot; DURATION 1d REPLICATION 1 DEFAULT</span><br></pre></td></tr></table></figure>
<h2 id="Chronograf"><a href="#Chronograf" class="headerlink" title="Chronograf"></a>Chronograf</h2><p>官方有一个叫TICK的技术栈推荐，但对于我们的场景，只要结合其中的IC就可以了，即influxdb和chronograf.</p>
<p><a href="https://docs.influxdata.com/influxdb/v1.2/introduction/installation/" target="_blank" rel="noopener">安装启动过程</a>不提</p>
<p>在使用它之前，需要先学习一下基本的<a href="https://docs.influxdata.com/influxdb/v1.4/query_language/data_exploration/" target="_blank" rel="noopener">influxdb查询语法</a></p>
<p><img src="http://7xqlni.com1.z0.glb.clouddn.com/chronograf.png" alt=""></p>
<p>这样，就可以轻松的在Chronograf中查询数据了，如果需要额外的数据，可以让业务方导出csv自行分析。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/后端/">后端</a><a href="/tags/influxdb/">influxdb</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/03/01/使用influxdb构建运营数据Metrics系统/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/25/linux服务管理-upstart/"><span>linux服务管理-upstart</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/25/linux服务管理-upstart/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-25T01:48:30.000Z">
          2018-02-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><img src="https://assets.digitalocean.com/articles/upstart_event_system/1.png" alt=""><br>当我们写完一个go程序时，部署只需要把二进制包拷贝到服务器上即可。</p>
<p>但在真正的<strong>生产环境</strong>中，如果程序出于某种原因崩溃了，我们会面临两个问题</p>
<ol>
<li>如何得知程序崩溃，如果靠人工的方式，无疑是有巨大时间滞后的</li>
<li>如何方便的在崩溃后重启</li>
</ol>
<p>在Ruby的世界中，例如unicorn这样的应用服务器，会有一个master进程，专门解决以上问题，当worker崩溃时，master就会重新fork出一个worker进程。</p>
<h3 id="upstart简介"><a href="#upstart简介" class="headerlink" title="upstart简介"></a>upstart简介</h3><p>upstart是linux主流发行版(ubuntu,RHEL…)本自带的进程管理系统</p>
<p>程序开发时需要注意的事项</p>
<p>作为程序开发人员，在编写系统服务时，需要了解 upstart 的一些特殊要求。只有符合这些要求的软件才可以被 upstart 管理。</p>
<p>规则一，派生次数需声明。</p>
<p>很多 Linux 后台服务都通过派生两次的技巧将自己变成后台服务程序。如果您编写的服务也采用了这个技术，就必须通过文档或其它的某种方式明确地让 upstart 的维护人员知道这一点，这将影响 upstart 的 expect stanza，我们在前面已经详细介绍过这个 stanza 的含义。</p>
<p>规则二，派生后即可用。</p>
<p>后台程序在完成第二次派生的时候，必须保证服务已经可用。因为 upstart 通过派生计数来决定服务是否处于就绪状态。</p>
<p>规则三，遵守 SIGHUP 的要求。</p>
<p>upstart 会给守护进程发送 SIGHUP 信号，此时，upstart 希望该守护进程做以下这些响应工作：</p>
<p>•完成所有必要的重新初始化工作，比如重新读取配置文件。这是因为 upstart 的命令”initctl reload”被设计为可以让服务在不重启的情况下更新配置。</p>
<p>•守护进程必须继续使用现有的 PID，即收到 SIGHUP 时不能调用 fork。如果服务必须在这里调用 fork，则等同于派生两次，参考上面的规则一的处理。这个规则保证了 upstart 可以继续使用 PID 管理本服务。</p>
<p>规则四，收到 SIGTEM 即 shutdown。</p>
<p>•当收到 SIGTERM 信号后，upstart 希望守护进程进程立即干净地退出，释放所有资源。如果一个进程在收到 SIGTERM 信号后不退出，upstart 将对其发送 SIGKILL 信号。</p>
<h3 id="日常upstart命令"><a href="#日常upstart命令" class="headerlink" title="日常upstart命令"></a>日常upstart命令</h3><table>
<thead>
<tr>
<th>全部</th>
<th>简写</th>
</tr>
</thead>
<tbody>
<tr>
<td>initctl start</td>
<td>start</td>
</tr>
<tr>
<td>initctl restart</td>
<td>restart</td>
</tr>
<tr>
<td>initctl reload</td>
<td>reload</td>
</tr>
<tr>
<td>initctl stop</td>
<td>stop</td>
</tr>
</tbody>
</table>
<h3 id="编写upstart配置文件"><a href="#编写upstart配置文件" class="headerlink" title="编写upstart配置文件"></a>编写upstart配置文件</h3><ol>
<li>upstart脚本必须包含一个exec或者script片段，用于启动你的程序</li>
<li>pre-start script and post-stop script是一些钩子，可以在程序启动前后做一些事</li>
<li>start on and stop on定义了何时启动、停止你的程序</li>
</ol>
<hr>
<p>golang多用于写网络服务，以Nginx的官方upstart脚本为参考比较合适</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># http://wiki.nginx.org/upstart</span><br><span class="line"># nginx</span><br><span class="line"></span><br><span class="line">description &quot;nginx http daemon&quot;</span><br><span class="line">author &quot;George Shammas &lt;georgyo@gmail.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">start on (filesystem and net-device-up IFACE!=lo) 两个条件 文件系统和网络设备启动以后</span><br><span class="line">stop on runlevel [!2345]</span><br><span class="line"></span><br><span class="line">env DAEMON=/usr/sbin/nginx</span><br><span class="line">env PID=/var/run/nginx.pid</span><br><span class="line"></span><br><span class="line">expect fork</span><br><span class="line">respawn</span><br><span class="line">respawn limit 10 5</span><br><span class="line">#oom never</span><br><span class="line"></span><br><span class="line">pre-start script</span><br><span class="line">        $DAEMON -t</span><br><span class="line">        if [ $? -ne 0 ] 判断nginx -t命令的返回值是否是0(不是EXIT_SUCCESS)</span><br><span class="line">                then exit $?</span><br><span class="line">        fi</span><br><span class="line">end script</span><br><span class="line"></span><br><span class="line">exec $DAEMON</span><br></pre></td></tr></table></figure>
<p>简单写一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># /etc/init/naievehttpserver.conf</span><br><span class="line">description &quot;naive http golang server&quot;</span><br><span class="line">author &quot;xxx&quot;</span><br><span class="line"></span><br><span class="line">start on (filesystem and net-device-up IFACE!=lo)</span><br><span class="line">stop on runlevel [!2345]</span><br><span class="line"></span><br><span class="line">respawn</span><br><span class="line"></span><br><span class="line">chdir /vagrant</span><br><span class="line"></span><br><span class="line">exec ./naivehttpserver</span><br></pre></td></tr></table></figure>
<p>这样，就可以使用<code>sudo start naivehttpserver</code>这样的命令来管理naivehttpserver服务了。</p>
<p>更全的用法可以看<a href="http://upstart.ubuntu.com/cookbook/" target="_blank" rel="noopener">http://upstart.ubuntu.com/cookbook/</a>和<a href="http://upstart.ubuntu.com/wiki/" target="_blank" rel="noopener">http://upstart.ubuntu.com/wiki/</a></p>
<h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h3><p>目前upstart有被systemd取代的趋势, 列一些资料</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html</a></li>
<li><a href="https://wiki.archlinux.org/index.php/systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87</a>)</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/index.html" target="_blank" rel="noopener">浅析 Linux 初始化 init 系统，第 2 部分</a></p>
<p><a href="http://upstart.ubuntu.com/getting-started.html" target="_blank" rel="noopener">http://upstart.ubuntu.com/getting-started.html</a></p>
<p><a href="http://blog.fens.me/linux-upstart/" target="_blank" rel="noopener">http://blog.fens.me/linux-upstart/</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/后端/">后端</a><a href="/tags/linux/">linux</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/02/25/linux服务管理-upstart/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/13/慢请求性能优化-300倍性能提升/"><span>请求优化-百倍性能提升</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/13/慢请求性能优化-300倍性能提升/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-13T06:02:29.000Z">
          2018-02-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="发现慢请求"><a href="#发现慢请求" class="headerlink" title="发现慢请求"></a>发现慢请求</h3><p>我们的整个web服务是基于Rails的，应用服务器是基于多进程模型的unicorn，因此，慢请求会对系统造成比较大的影响。</p>
<p>最近又到了春节促销活动时期，为了更及时地发现整个后端系统的问题，我基于Kibana的Visulize功能制作了一个慢请求监控图</p>
<p><img src="http://7xqlni.com1.z0.glb.clouddn.com/kibanaa.png" alt=""></p>
<p>通过这个统计图，可以很方便的看出过去N分钟内，响应时间最慢的接口分布情况。</p>
<h3 id="优化-Cache"><a href="#优化-Cache" class="headerlink" title="优化-Cache"></a>优化-Cache</h3><p>对于图中这个<code>api/v1/publishers</code>接口，会出现很多耗时<code>100ms以上</code>的请求，这个接口做了以下几件事。</p>
<ol>
<li>查询数据库，加载一个几乎不怎么变动的publisher列表</li>
<li>渲染成json返回</li>
</ol>
<p>显而易见的优化策略就是cache掉数据库查询，做完这一步的确也能获得比较大的提升，普通的优化工作可能到这一步就结束了。</p>
<p>但是还有一个特殊的地方，这个列表可能有几百个条目，相对来说还是比较大的。而ruby在做这种CPU密集的渲染时，性能是非常差的。因此，也要想办法解决掉渲染的问题。</p>
<h3 id="优化-Render"><a href="#优化-Render" class="headerlink" title="优化-Render"></a>优化-Render</h3><p>只render一次。</p>
<p>相比于之前cache数据库查询的结果的方式，这次在代码中计算出最终返回的json，直接cache这个json字符串。</p>
<p>然后，在渲染的时候，使用渲染文本，并手动设置content-type的方式来返回json</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render <span class="symbol">plain:</span> <span class="string">"字符串"</span>, <span class="symbol">content_type:</span> <span class="string">'application/json'</span></span><br></pre></td></tr></table></figure>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>做完以上两步，在日志中观察到单个请求的时间降低到<code>0.8ms</code>左右！</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>以上优化差不多是Rails框架内的极致，再往上，可以考虑直接把数据静态化成json文件，交给Nginx管理。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/后端/">后端</a><a href="/tags/ELK/">ELK</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/02/13/慢请求性能优化-300倍性能提升/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/07/也谈服务注册与发现/"><span>也谈服务注册与发现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/07/也谈服务注册与发现/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-07T05:22:25.000Z">
          2018-02-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>公司后端是基于ROR的，应用服务器是unicorn，搞活动高峰期，缺乏一种动态改变配置后，就可以控制程序行为的能力。</p>
<p>受限于Rails和Unicorn的多进程模型，初步的方案就是往Cache里扔一个值，接口每次都检查这个值，但这样就多了一次<strong>网络IO</strong>，不太Geek。</p>
<p>深入思考了一下，觉得可以做一个配置中心，unicorn启动的时候,建立长连接到配置中心获取数据，配置发生改变的时候通过长连接通知到unicorn，从而动态改变了所有服务器上的本地内存。然后又在考虑，是每个unicorn worker都保持一个连接？还是只有master保持连接，通过一些进程间通信技术通知到worker？又或者单独做一个agent，让agent去保持连接，然后写到unix socket里，unicorn读这个socket？…</p>
<p>最终由于改不动unicorn的代码, 放弃了。</p>
<p><img src="http://7xqlni.com1.z0.glb.clouddn.com/think.jpg" alt=""></p>
<p>后来转念一想，这不就是etcd解决的问题!只不过详细的方案还需要基于etcd自己设计。</p>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>服务有一个唯一id，id是调用方和提供方都知道的。</p>
<p>大致流程:</p>
<ul>
<li>提供方： 往etcd里put一个键值对，key是服务id，值是对应的配置</li>
<li>掉用方： 根据key向etcd获取配置，并进行watch</li>
<li>配置改变时,调用方可以通过watch得知</li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>根据官方文档装好etcd,<a href="https://coreos.com/etcd/docs/latest/dl_build.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/dl_build.html</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/coreos/etcd.git</span><br><span class="line"><span class="built_in">cd</span> etcd</span><br><span class="line">./build</span><br><span class="line">./bin/etcd</span><br></pre></td></tr></table></figure>
<p>写一个简单的服务注册<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"github.com/coreos/etcd/clientv3"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    id      <span class="keyword">string</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> info = ServiceInfo&#123;<span class="string">"/service/b"</span>, <span class="string">"10.1.1.60:8081"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cli, err := clientv3.New(clientv3.Config&#123;</span><br><span class="line">        Endpoints:   []<span class="keyword">string</span>&#123;<span class="string">"localhost:2379"</span>&#125;,</span><br><span class="line">        DialTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> cli.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, err := cli.Put(context.TODO(), info.id, info.address); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resp, err := cli.Get(context.TODO(), info.id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"resp: "</span>, resp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写个简单的go服务a, 通过etcd来发现服务b的地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/coreos/etcd/clientv3"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    id      <span class="keyword">string</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> info = ServiceInfo&#123;<span class="string">"/service/a"</span>, <span class="string">"10.1.1.59:8080"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> infoB = ServiceInfo&#123;id: <span class="string">"/service/b"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">"/"</span>, hello)</span><br><span class="line">        http.ListenAndServe(info.address, <span class="literal">nil</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    etcd()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"hello this is %s, B address is %s"</span>, info.id, infoB.address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">etcd</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cli, err := clientv3.New(clientv3.Config&#123;</span><br><span class="line">        Endpoints:   []<span class="keyword">string</span>&#123;<span class="string">"localhost:2379"</span>&#125;,</span><br><span class="line">        DialTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> cli.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// regist self</span></span><br><span class="line">    <span class="keyword">if</span> _, err := cli.Put(context.TODO(), info.id, info.address); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get service b info</span></span><br><span class="line">    <span class="keyword">if</span> resp, err := cli.Get(context.TODO(), infoB.id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, ev := <span class="keyword">range</span> resp.Kvs &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%s : %s\n"</span>, ev.Key, ev.Value)</span><br><span class="line">            infoB.address = <span class="keyword">string</span>(ev.Value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// watch changes</span></span><br><span class="line">    rch := cli.Watch(context.TODO(), infoB.id, clientv3.WithPrefix())</span><br><span class="line">    <span class="keyword">for</span> wresp := <span class="keyword">range</span> rch &#123;</span><br><span class="line">        <span class="keyword">for</span> _, ev := <span class="keyword">range</span> wresp.Events &#123;</span><br><span class="line">            log.Printf(<span class="string">"%s %q : %q\n"</span>, ev.Type, ev.Kv.Key, ev.Kv.Value)</span><br><span class="line">            infoB.address = <span class="keyword">string</span>(ev.Kv.Value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是， a服务可以获取到b的地址，在<code>/service/b</code>这个key改变时，也可以通过watch得到最新的值。</p>
<h3 id="服务挂掉的处理"><a href="#服务挂掉的处理" class="headerlink" title="服务挂掉的处理"></a>服务挂掉的处理</h3><p>以上的例子可能有点不太恰当，因为偏向于一个动态的配置中心，我们不需要监测服务是否存活，因为etcd本身就是服务。</p>
<p>对于一般的服务，如果挂了，以上的方式是无法处理的。解决方式是给key设置一个ttl,每隔一段时间刷新ttl。通过这种类似心跳的方式来实现。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://github.com/coreos/etcd/blob/a0e17f69a2e060250251e1c31f6d8dde01cc4932/clientv3/example_kv_test.go" target="_blank" rel="noopener">https://github.com/coreos/etcd/blob/a0e17f69a2e060250251e1c31f6d8dde01cc4932/clientv3/example_kv_test.go</a></li>
<li><a href="https://github.com/coreos/etcd/blob/a0e17f69a2e060250251e1c31f6d8dde01cc4932/clientv3/example_watch_test.go" target="_blank" rel="noopener">https://github.com/coreos/etcd/blob/a0e17f69a2e060250251e1c31f6d8dde01cc4932/clientv3/example_watch_test.go</a></li>
<li><a href="https://coreos.com/etcd/docs/latest/dl_build.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/dl_build.html</a></li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/etcd/">etcd</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/02/07/也谈服务注册与发现/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
  </p>
</footer>
    
  </div>
</div>
</body>
</html>