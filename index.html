<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Moon&#39;s blog | write the code, change the world.</title>

  
  <meta name="author" content="Moon">
  

  
  <meta name="description" content="Ruby\Golang">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Moon&#39;s blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Moon&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?a9ab16fc25a6e74e9e3521e7ad3782e8";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Moon&#39;s blog</a>
    </h1>
    <p class="site-description">write the code, change the world.</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/01/使用influxdb构建运营数据Metrics系统/"><span>使用influxdb收集用户行为数据</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/01/使用influxdb构建运营数据Metrics系统/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-01T06:25:40.000Z">
          2018-03-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>目前我们需要收集一些用户在站点上的行为数据。</p>
<p>influxdb内置了HTTP API,免去了编写接入代码的繁琐，并带有数据查询和展示的组件，非常适合。</p>
<p>安装过程略去不提，参考<a href="https://docs.influxdata.com/influxdb/v1.4/introduction/getting_started/" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>Influxdb</li>
<li>Chronograf</li>
<li>例子</li>
</ul>
<h2 id="Influxdb"><a href="#Influxdb" class="headerlink" title="Influxdb"></a>Influxdb</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一条influxdb的记录的结构是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;measurement&gt;[,&lt;tag-key&gt;=&lt;tag-value&gt;...] &lt;field-key&gt;=&lt;field-value&gt;[,&lt;field2-key&gt;=&lt;field2-value&gt;...] [unix-nano-timestamp]</span><br><span class="line"></span><br><span class="line">例如</span><br><span class="line"></span><br><span class="line">cpu,host=serverA,region=us_west value=0.64</span><br><span class="line">payment,device=mobile,product=Notepad,method=credit billed=33,licenses=3i 1434067467100293230</span><br><span class="line">stock,symbol=AAPL bid=127.46,ask=127.48</span><br><span class="line">temperature,machine=unit42,type=assembly external=25,internal=37 1434067467000000000</span><br></pre></td></tr></table></figure>
<p>类比于RDMBS</p>
<table>
<thead>
<tr>
<th>influxdb</th>
<th>rdbms</th>
</tr>
</thead>
<tbody>
<tr>
<td>unix-nano-timestamp</td>
<td>primary key</td>
</tr>
<tr>
<td>measurement</td>
<td>table</td>
</tr>
<tr>
<td>tag</td>
<td>indexed column</td>
</tr>
<tr>
<td>fields</td>
<td>column</td>
</tr>
</tbody>
</table>
<h3 id="HTTP-API"><a href="#HTTP-API" class="headerlink" title="HTTP API"></a>HTTP API</h3><p>influxdb的所有操作都可以通过HTTP API来完成</p>
<p><a href="https://docs.influxdata.com/influxdb/v1.4/guides/writing_data/" target="_blank" rel="noopener">写数据</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XPOST &apos;http://localhost:8086/write?db=mydb&apos; --data-binary &apos;cpu_load_short,host=server01,region=us-west value=0.64 1434055562000000000&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="Authentication-amp-Authorization"><a href="#Authentication-amp-Authorization" class="headerlink" title="Authentication &amp; Authorization"></a>Authentication &amp; Authorization</h3><p>通过HTTP API可以进行DDL操作，我们需要有一些<a href="https://docs.influxdata.com/influxdb/v1.4/query_language/authentication_and_authorization/#authorization" target="_blank" rel="noopener">权限机制</a>来保证安全.</p>
<ol>
<li>修改配置文件<strong>/etc/influxdb/influxdb.conf</strong>并重启</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[http]</span><br><span class="line">  ...</span><br><span class="line">  auth-enabled = true</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<ol>
<li>创建用户</li>
</ol>
<p>创建超级用户admin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER admin WITH PASSWORD &apos;123456&apos; WITH ALL PRIVILEGES</span><br></pre></td></tr></table></figure>
<p>创建普通用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER reader WITH PASSWORD &apos;123456&apos;</span><br><span class="line">GRANT READ ON &quot;mydb&quot; TO &quot;reader&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Rentention-Policy"><a href="#Rentention-Policy" class="headerlink" title="Rentention Policy"></a>Rentention Policy</h3><p>时序数据的量可能会非常大，需要定义保存数据的<a href="https://docs.influxdata.com/influxdb/v1.4/query_language/database_management/#retention-policy-management" target="_blank" rel="noopener">策略</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE RETENTION POLICY &quot;one_day_only&quot; ON &quot;mydb&quot; DURATION 1d REPLICATION 1 DEFAULT</span><br></pre></td></tr></table></figure>
<h2 id="Chronograf"><a href="#Chronograf" class="headerlink" title="Chronograf"></a>Chronograf</h2><p>官方有一个叫TICK的技术栈推荐，但对于我们的场景，只要结合其中的IC就可以了，即influxdb和chronograf.</p>
<p><a href="https://docs.influxdata.com/influxdb/v1.2/introduction/installation/" target="_blank" rel="noopener">安装启动过程</a>不提</p>
<p>在使用它之前，需要先学习一下基本的<a href="https://docs.influxdata.com/influxdb/v1.4/query_language/data_exploration/" target="_blank" rel="noopener">influxdb查询语法</a></p>
<p><img src="http://7xqlni.com1.z0.glb.clouddn.com/chronograf.png" alt=""></p>
<p>这样，就可以轻松的在Chronograf中查询数据了，如果需要额外的数据，可以让业务方导出csv自行分析。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/后端/">后端</a><a href="/tags/golang/">golang</a><a href="/tags/influxdb/">influxdb</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/03/01/使用influxdb构建运营数据Metrics系统/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/25/linux服务管理-upstart/"><span>linux服务管理-upstart</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/25/linux服务管理-upstart/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-25T01:48:30.000Z">
          2018-02-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><img src="https://assets.digitalocean.com/articles/upstart_event_system/1.png" alt=""><br>当我们写完一个go程序时，部署只需要把二进制包拷贝到服务器上即可。</p>
<p>但在真正的<strong>生产环境</strong>中，如果程序出于某种原因崩溃了，我们会面临两个问题</p>
<ol>
<li>如何得知程序崩溃，如果靠人工的方式，无疑是有巨大时间滞后的</li>
<li>如何方便的在崩溃后重启</li>
</ol>
<p>在Ruby的世界中，例如unicorn这样的应用服务器，会有一个master进程，专门解决以上问题，当worker崩溃时，master就会重新fork出一个worker进程。</p>
<h3 id="upstart简介"><a href="#upstart简介" class="headerlink" title="upstart简介"></a>upstart简介</h3><p>upstart是linux主流发行版(ubuntu,RHEL…)本自带的进程管理系统</p>
<p>程序开发时需要注意的事项</p>
<p>作为程序开发人员，在编写系统服务时，需要了解 upstart 的一些特殊要求。只有符合这些要求的软件才可以被 upstart 管理。</p>
<p>规则一，派生次数需声明。</p>
<p>很多 Linux 后台服务都通过派生两次的技巧将自己变成后台服务程序。如果您编写的服务也采用了这个技术，就必须通过文档或其它的某种方式明确地让 upstart 的维护人员知道这一点，这将影响 upstart 的 expect stanza，我们在前面已经详细介绍过这个 stanza 的含义。</p>
<p>规则二，派生后即可用。</p>
<p>后台程序在完成第二次派生的时候，必须保证服务已经可用。因为 upstart 通过派生计数来决定服务是否处于就绪状态。</p>
<p>规则三，遵守 SIGHUP 的要求。</p>
<p>upstart 会给守护进程发送 SIGHUP 信号，此时，upstart 希望该守护进程做以下这些响应工作：</p>
<p>•完成所有必要的重新初始化工作，比如重新读取配置文件。这是因为 upstart 的命令”initctl reload”被设计为可以让服务在不重启的情况下更新配置。</p>
<p>•守护进程必须继续使用现有的 PID，即收到 SIGHUP 时不能调用 fork。如果服务必须在这里调用 fork，则等同于派生两次，参考上面的规则一的处理。这个规则保证了 upstart 可以继续使用 PID 管理本服务。</p>
<p>规则四，收到 SIGTEM 即 shutdown。</p>
<p>•当收到 SIGTERM 信号后，upstart 希望守护进程进程立即干净地退出，释放所有资源。如果一个进程在收到 SIGTERM 信号后不退出，upstart 将对其发送 SIGKILL 信号。</p>
<h3 id="日常upstart命令"><a href="#日常upstart命令" class="headerlink" title="日常upstart命令"></a>日常upstart命令</h3><table>
<thead>
<tr>
<th>全部</th>
<th>简写</th>
</tr>
</thead>
<tbody>
<tr>
<td>initctl start</td>
<td>start</td>
</tr>
<tr>
<td>initctl restart</td>
<td>restart</td>
</tr>
<tr>
<td>initctl reload</td>
<td>reload</td>
</tr>
<tr>
<td>initctl stop</td>
<td>stop</td>
</tr>
</tbody>
</table>
<h3 id="编写upstart配置文件"><a href="#编写upstart配置文件" class="headerlink" title="编写upstart配置文件"></a>编写upstart配置文件</h3><ol>
<li>upstart脚本必须包含一个exec或者script片段，用于启动你的程序</li>
<li>pre-start script and post-stop script是一些钩子，可以在程序启动前后做一些事</li>
<li>start on and stop on定义了何时启动、停止你的程序</li>
</ol>
<hr>
<p>golang多用于写网络服务，以Nginx的官方upstart脚本为参考比较合适</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># http://wiki.nginx.org/upstart</span><br><span class="line"># nginx</span><br><span class="line"></span><br><span class="line">description &quot;nginx http daemon&quot;</span><br><span class="line">author &quot;George Shammas &lt;georgyo@gmail.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">start on (filesystem and net-device-up IFACE!=lo) 两个条件 文件系统和网络设备启动以后</span><br><span class="line">stop on runlevel [!2345]</span><br><span class="line"></span><br><span class="line">env DAEMON=/usr/sbin/nginx</span><br><span class="line">env PID=/var/run/nginx.pid</span><br><span class="line"></span><br><span class="line">expect fork</span><br><span class="line">respawn</span><br><span class="line">respawn limit 10 5</span><br><span class="line">#oom never</span><br><span class="line"></span><br><span class="line">pre-start script</span><br><span class="line">        $DAEMON -t</span><br><span class="line">        if [ $? -ne 0 ] 判断nginx -t命令的返回值是否是0(不是EXIT_SUCCESS)</span><br><span class="line">                then exit $?</span><br><span class="line">        fi</span><br><span class="line">end script</span><br><span class="line"></span><br><span class="line">exec $DAEMON</span><br></pre></td></tr></table></figure>
<p>简单写一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># /etc/init/naievehttpserver.conf</span><br><span class="line">description &quot;naive http golang server&quot;</span><br><span class="line">author &quot;xxx&quot;</span><br><span class="line"></span><br><span class="line">start on (filesystem and net-device-up IFACE!=lo)</span><br><span class="line">stop on runlevel [!2345]</span><br><span class="line"></span><br><span class="line">respawn</span><br><span class="line"></span><br><span class="line">chdir /vagrant</span><br><span class="line"></span><br><span class="line">exec ./naivehttpserver</span><br></pre></td></tr></table></figure>
<p>这样，就可以使用<code>sudo start naivehttpserver</code>这样的命令来管理naivehttpserver服务了。</p>
<p>更全的用法可以看<a href="http://upstart.ubuntu.com/cookbook/" target="_blank" rel="noopener">http://upstart.ubuntu.com/cookbook/</a>和<a href="http://upstart.ubuntu.com/wiki/" target="_blank" rel="noopener">http://upstart.ubuntu.com/wiki/</a></p>
<h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h3><p>目前upstart有被systemd取代的趋势, 列一些资料</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html</a></li>
<li><a href="https://wiki.archlinux.org/index.php/systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87</a>)</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/index.html" target="_blank" rel="noopener">浅析 Linux 初始化 init 系统，第 2 部分</a></p>
<p><a href="http://upstart.ubuntu.com/getting-started.html" target="_blank" rel="noopener">http://upstart.ubuntu.com/getting-started.html</a></p>
<p><a href="http://blog.fens.me/linux-upstart/" target="_blank" rel="noopener">http://blog.fens.me/linux-upstart/</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/后端/">后端</a><a href="/tags/linux/">linux</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/02/25/linux服务管理-upstart/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/13/慢请求性能优化-300倍性能提升/"><span>请求优化-百倍性能提升</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/13/慢请求性能优化-300倍性能提升/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-13T06:02:29.000Z">
          2018-02-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="发现慢请求"><a href="#发现慢请求" class="headerlink" title="发现慢请求"></a>发现慢请求</h3><p>我们的整个web服务是基于Rails的，应用服务器是基于多进程模型的unicorn，因此，慢请求会对系统造成比较大的影响。</p>
<p>最近又到了春节促销活动时期，为了更及时地发现整个后端系统的问题，我基于Kibana的Visulize功能制作了一个慢请求监控图</p>
<p><img src="http://7xqlni.com1.z0.glb.clouddn.com/kibanaa.png" alt=""></p>
<p>通过这个统计图，可以很方便的看出过去N分钟内，响应时间最慢的接口分布情况。</p>
<h3 id="优化-Cache"><a href="#优化-Cache" class="headerlink" title="优化-Cache"></a>优化-Cache</h3><p>对于图中这个<code>api/v1/publishers</code>接口，会出现很多耗时<code>100ms以上</code>的请求，这个接口做了以下几件事。</p>
<ol>
<li>查询数据库，加载一个几乎不怎么变动的publisher列表</li>
<li>渲染成json返回</li>
</ol>
<p>显而易见的优化策略就是cache掉数据库查询，做完这一步的确也能获得比较大的提升，普通的优化工作可能到这一步就结束了。</p>
<p>但是还有一个特殊的地方，这个列表可能有几百个条目，相对来说还是比较大的。而ruby在做这种CPU密集的渲染时，性能是非常差的。因此，也要想办法解决掉渲染的问题。</p>
<h3 id="优化-Render"><a href="#优化-Render" class="headerlink" title="优化-Render"></a>优化-Render</h3><p>只render一次。</p>
<p>相比于之前cache数据库查询的结果的方式，这次在代码中计算出最终返回的json，直接cache这个json字符串。</p>
<p>然后，在渲染的时候，使用渲染文本，并手动设置content-type的方式来返回json</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render <span class="symbol">plain:</span> <span class="string">"字符串"</span>, <span class="symbol">content_type:</span> <span class="string">'application/json'</span></span><br></pre></td></tr></table></figure>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>做完以上两步，在日志中观察到单个请求的时间降低到<code>0.8ms</code>左右！</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>以上优化差不多是Rails框架内的极致，再往上，可以考虑直接把数据静态化成json文件，交给Nginx管理。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/后端/">后端</a><a href="/tags/ELK/">ELK</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/02/13/慢请求性能优化-300倍性能提升/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/07/也谈服务注册与发现/"><span>也谈服务注册与发现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/07/也谈服务注册与发现/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-07T05:22:25.000Z">
          2018-02-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>公司后端是基于ROR的，应用服务器是unicorn，搞活动高峰期，缺乏一种动态改变配置后，就可以控制程序行为的能力。</p>
<p>受限于Rails和Unicorn的多进程模型，初步的方案就是往Cache里扔一个值，接口每次都检查这个值，但这样就多了一次<strong>网络IO</strong>，不太Geek。</p>
<p>深入思考了一下，觉得可以做一个配置中心，unicorn启动的时候,建立长连接到配置中心获取数据，配置发生改变的时候通过长连接通知到unicorn，从而动态改变了所有服务器上的本地内存。然后又在考虑，是每个unicorn worker都保持一个连接？还是只有master保持连接，通过一些进程间通信技术通知到worker？又或者单独做一个agent，让agent去保持连接，然后写到unix socket里，unicorn读这个socket？…</p>
<p>最终由于改不动unicorn的代码, 放弃了。</p>
<p><img src="http://7xqlni.com1.z0.glb.clouddn.com/think.jpg" alt=""></p>
<p>后来转念一想，这不就是etcd解决的问题!只不过详细的方案还需要基于etcd自己设计。</p>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>服务有一个唯一id，id是调用方和提供方都知道的。</p>
<p>大致流程:</p>
<ul>
<li>提供方： 往etcd里put一个键值对，key是服务id，值是对应的配置</li>
<li>掉用方： 根据key向etcd获取配置，并进行watch</li>
<li>配置改变时,调用方可以通过watch得知</li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>根据官方文档装好etcd,<a href="https://coreos.com/etcd/docs/latest/dl_build.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/dl_build.html</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/coreos/etcd.git</span><br><span class="line"><span class="built_in">cd</span> etcd</span><br><span class="line">./build</span><br><span class="line">./bin/etcd</span><br></pre></td></tr></table></figure>
<p>写一个简单的服务注册<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"github.com/coreos/etcd/clientv3"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    id      <span class="keyword">string</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> info = ServiceInfo&#123;<span class="string">"/service/b"</span>, <span class="string">"10.1.1.60:8081"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cli, err := clientv3.New(clientv3.Config&#123;</span><br><span class="line">        Endpoints:   []<span class="keyword">string</span>&#123;<span class="string">"localhost:2379"</span>&#125;,</span><br><span class="line">        DialTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> cli.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, err := cli.Put(context.TODO(), info.id, info.address); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resp, err := cli.Get(context.TODO(), info.id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"resp: "</span>, resp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写个简单的go服务a, 通过etcd来发现服务b的地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/coreos/etcd/clientv3"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    id      <span class="keyword">string</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> info = ServiceInfo&#123;<span class="string">"/service/a"</span>, <span class="string">"10.1.1.59:8080"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> infoB = ServiceInfo&#123;id: <span class="string">"/service/b"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">"/"</span>, hello)</span><br><span class="line">        http.ListenAndServe(info.address, <span class="literal">nil</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    etcd()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"hello this is %s, B address is %s"</span>, info.id, infoB.address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">etcd</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cli, err := clientv3.New(clientv3.Config&#123;</span><br><span class="line">        Endpoints:   []<span class="keyword">string</span>&#123;<span class="string">"localhost:2379"</span>&#125;,</span><br><span class="line">        DialTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> cli.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// regist self</span></span><br><span class="line">    <span class="keyword">if</span> _, err := cli.Put(context.TODO(), info.id, info.address); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get service b info</span></span><br><span class="line">    <span class="keyword">if</span> resp, err := cli.Get(context.TODO(), infoB.id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, ev := <span class="keyword">range</span> resp.Kvs &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%s : %s\n"</span>, ev.Key, ev.Value)</span><br><span class="line">            infoB.address = <span class="keyword">string</span>(ev.Value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// watch changes</span></span><br><span class="line">    rch := cli.Watch(context.TODO(), infoB.id, clientv3.WithPrefix())</span><br><span class="line">    <span class="keyword">for</span> wresp := <span class="keyword">range</span> rch &#123;</span><br><span class="line">        <span class="keyword">for</span> _, ev := <span class="keyword">range</span> wresp.Events &#123;</span><br><span class="line">            log.Printf(<span class="string">"%s %q : %q\n"</span>, ev.Type, ev.Kv.Key, ev.Kv.Value)</span><br><span class="line">            infoB.address = <span class="keyword">string</span>(ev.Kv.Value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是， a服务可以获取到b的地址，在<code>/service/b</code>这个key改变时，也可以通过watch得到最新的值。</p>
<h3 id="服务挂掉的处理"><a href="#服务挂掉的处理" class="headerlink" title="服务挂掉的处理"></a>服务挂掉的处理</h3><p>如果服务挂了，以上的方式是无法处理的，解决方式是给key设置一个ttl,每隔一段时间刷新ttl。通过这种类似心跳的方式来实现。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://github.com/coreos/etcd/blob/a0e17f69a2e060250251e1c31f6d8dde01cc4932/clientv3/example_kv_test.go" target="_blank" rel="noopener">https://github.com/coreos/etcd/blob/a0e17f69a2e060250251e1c31f6d8dde01cc4932/clientv3/example_kv_test.go</a></li>
<li><a href="https://github.com/coreos/etcd/blob/a0e17f69a2e060250251e1c31f6d8dde01cc4932/clientv3/example_watch_test.go" target="_blank" rel="noopener">https://github.com/coreos/etcd/blob/a0e17f69a2e060250251e1c31f6d8dde01cc4932/clientv3/example_watch_test.go</a></li>
<li><a href="https://coreos.com/etcd/docs/latest/dl_build.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/dl_build.html</a></li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/etcd/">etcd</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/02/07/也谈服务注册与发现/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/05/FishChatServer源码探究/"><span>FishChatServer源码探究</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/05/FishChatServer源码探究/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-05T09:53:02.000Z">
          2018-02-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在写im-go的过程中遇到了一些设计上的问题，于是想找目前有的开源im服务的源码看看。<a href="https://github.com/oikomi/FishChatServer2" target="_blank" rel="noopener">FishChatServer2</a>在一些模块设计上和我的思路很相似，有种英雄所见略同的快感，所以选了它(FishChatServer2的拆包方式和我<a href="https://moonshining.github.io/blog/2018/02/05/golang-tcp%E6%8B%86%E5%8C%85%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF">上一篇文章</a>中提到的使用<code>ReadFull</code>的方式是一样的，并且连模块名字都一样叫Codec)</p>
<p>主要看了libnet和server两个模块</p>
<p>libnet, 是所有server的基础公共库，封装了诸如Listen Accept之类的调用<br><img src="http://7xqlni.com1.z0.glb.clouddn.com/libnet.png" alt=""></p>
<p>server, 具体的服务，看了一下gateway和access两个服务的实现<br><img src="http://7xqlni.com1.z0.glb.clouddn.com/server.png" alt=""></p>
<hr>
<h3 id="gateway服务"><a href="#gateway服务" class="headerlink" title="gateway服务"></a>gateway服务</h3><p><strong>gateway.go</strong>是gateway服务的入口，其实是一个access服务的负载均衡器，核心代码如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化对象</span></span><br><span class="line">gwServer := server.New() </span><br><span class="line"><span class="comment">// codec编码、解码器</span></span><br><span class="line">protobuf := codec.Protobuf() </span><br><span class="line"><span class="comment">// 使用libnet封装的api进行Listen</span></span><br><span class="line"><span class="keyword">if</span> gwServer.Server, err = libnet.Serve(conf.Conf.Server.Proto, conf.Conf.Server.Addr, protobuf, <span class="number">0</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    glog.Error(err)</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 通过etcd进行服务发现，每5秒向etcd请求一个access服务器列表，并写入AccessServerList 这个变量中</span></span><br><span class="line"><span class="keyword">go</span> job.ConfDiscoveryProc() </span><br><span class="line">gwServer.Loop() <span class="comment">// 开始不断循环处理请求</span></span><br></pre></td></tr></table></figure>
<p><code>gwServer.Loop()</code>的核心代码在<strong>server.go</strong>中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">sessionLoop</span><span class="params">(client *client.Client)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//读一个包</span></span><br><span class="line">        reqData, err := client.Session.Receive() </span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Error(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> reqData != <span class="literal">nil</span> &#123;</span><br><span class="line">            baseCMD := &amp;external.Base&#123;&#125;</span><br><span class="line">            <span class="comment">// protobuf 反序列化</span></span><br><span class="line">            <span class="keyword">if</span> err = proto.Unmarshal(reqData, baseCMD); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err = client.Session.Send(&amp;external.Error&#123;</span><br><span class="line">                    Cmd:     external.ErrServerCMD,</span><br><span class="line">                    ErrCode: ecode.ServerErr.Uint32(),</span><br><span class="line">                    ErrStr:  ecode.ServerErr.String(),</span><br><span class="line">                &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    glog.Error(err)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// client.Parse方法有一点迷惑性，client.Parse 其实做了解析命令，并执行命令的工作</span></span><br><span class="line">            <span class="keyword">if</span> err = client.Parse(baseCMD.Cmd, reqData); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                glog.Error(err)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Loop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    glog.Info(<span class="string">"loop"</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 获取libnet封装的session对象</span></span><br><span class="line">        session, err := s.Server.Accept() </span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Error(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成client对象，里面封装了gateway服务的业务逻辑</span></span><br><span class="line">        <span class="keyword">go</span> s.sessionLoop(client.New(session)) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client.Parse最终调用了<strong>proto_proc.go</strong>里的<strong>client.procReqAccessServer</strong>来执行业务逻辑<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">procReqAccessServer</span><span class="params">(reqData []<span class="keyword">byte</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> addr <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> accessServerList []<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// 从之前提到的access服务地址数组中获取一个可用的access服务</span></span><br><span class="line">    <span class="comment">// 没有看懂为什么要做一次额外的复制数组的操作？</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> job.AccessServerList &#123;</span><br><span class="line">        accessServerList = <span class="built_in">append</span>(accessServerList, v.IP)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理错误情况</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(accessServerList) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err = c.Session.Send(&amp;external.ResSelectAccessServerForClient&#123;</span><br><span class="line">            Cmd:     external.ReqAccessServerCMD,</span><br><span class="line">            ErrCode: ecode.NoAccessServer.Uint32(),</span><br><span class="line">            ErrStr:  ecode.NoAccessServer.String(),</span><br><span class="line">        &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            glog.Error(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个可用地址</span></span><br><span class="line">    addr = accessServerList[rand.Intn(<span class="built_in">len</span>(accessServerList))]</span><br><span class="line">    <span class="keyword">if</span> err = c.Session.Send(&amp;external.ResSelectAccessServerForClient&#123;</span><br><span class="line">        Cmd:     external.ReqAccessServerCMD,</span><br><span class="line">        ErrCode: ecode.OK.Uint32(),</span><br><span class="line">        ErrStr:  ecode.OK.String(),</span><br><span class="line">        Addr:    addr,</span><br><span class="line">    &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        glog.Error(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此一次请求就结束了，可用看出代码的结构上非常清晰，很容易就能理解。</p>
<hr>
<h3 id="libnet"><a href="#libnet" class="headerlink" title="libnet"></a>libnet</h3><p>这个模块帮我们屏蔽了大量繁琐的网络细节，接下来就要看一下它的实现了。</p>
<p>从<strong>api.go</strong>入手，这里定义了对外的接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Protocol <span class="keyword">interface</span> &#123; </span><br><span class="line">    <span class="comment">// Codec 负责通信协议的解析，封装了读写数据的方法</span></span><br><span class="line">    NewCodec(rw io.ReadWriter) Codec </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Codec <span class="keyword">interface</span> &#123;</span><br><span class="line">    Receive() ([]<span class="keyword">byte</span>, error)</span><br><span class="line">    Send(<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(network, address <span class="keyword">string</span>, protocol Protocol, sendChanSize <span class="keyword">int</span>)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">    listener, err := net.Listen(network, address) <span class="comment">// 终于看到标准库里的东西了</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// listener用于Accept， protocol用户处理net.Conn, sendChanSize看上去好像是用来控制发送速率的，不过没有明白为什么需要控制?</span></span><br><span class="line">    <span class="keyword">return</span> NewServer(listener, protocol, sendChanSize), <span class="literal">nil</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端连接+带超时的连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Connect</span><span class="params">(network, address <span class="keyword">string</span>, protocol Protocol, sendChanSize <span class="keyword">int</span>)</span> <span class="params">(*Session, error)</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(network, address)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NewSession(protocol.NewCodec(conn), sendChanSize), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConnectTimeout</span><span class="params">(network, address <span class="keyword">string</span>, timeout time.Duration, protocol Protocol, sendChanSize <span class="keyword">int</span>)</span> <span class="params">(*Session, error)</span></span> &#123;</span><br><span class="line">    conn, err := net.DialTimeout(network, address, timeout)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NewSession(protocol.NewCodec(conn), sendChanSize), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跳过客户的部分的实现，探索一下<strong>server.go</strong>,负责Accept一个连接，并且封装好一个session对象返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">Accept</span><span class="params">()</span> <span class="params">(*Session, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := server.listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 处理Temporary Error应该是参考了goblog里的error-handling-and-go章节</span></span><br><span class="line">            <span class="comment">// For instance, a web crawler might sleep and retry when it encounters a temporary error and give up otherwise.</span></span><br><span class="line">            <span class="keyword">if</span> ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 感觉直接比较字符串有点太粗暴了？ 但应该是没有办法区分的原因</span></span><br><span class="line">            <span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">"use of closed network connection"</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, io.EOF</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> server.manager.NewSession(</span><br><span class="line">            server.protocol.NewCodec(conn),</span><br><span class="line">            server.sendChanSize,</span><br><span class="line">        ), <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>manager.go</strong>用于管理session，会把session根据id mod 32以后，放进对应的map里, 这里使用了lock来保证并发安全, 但golang1.9以后，应该可以用内置的<strong>sync.Map</strong>替代了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">NewSession</span><span class="params">(codec Codec, sendChanSize <span class="keyword">int</span>)</span> *<span class="title">Session</span></span> &#123;</span><br><span class="line">    session := newSession(manager, codec, sendChanSize)</span><br><span class="line">    manager.putSession(session)</span><br><span class="line">    <span class="keyword">return</span> session</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *Manager)</span> <span class="title">putSession</span><span class="params">(session *Session)</span></span> &#123;</span><br><span class="line">    smap := &amp;manager.sessionMaps[session.id%sessionMapNum]</span><br><span class="line">    smap.Lock()</span><br><span class="line">    <span class="keyword">defer</span> smap.Unlock()</span><br><span class="line">    smap.sessions[session.id] = session</span><br><span class="line">    manager.disposeWait.Add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>server在Accept之后，返回的是一个session对象,session负责收发数据，并且实现了<strong>优雅退出(gracefully shutdown)</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Session <span class="keyword">struct</span> &#123;</span><br><span class="line">    id             <span class="keyword">uint64</span></span><br><span class="line">    codec          Codec</span><br><span class="line">    manager        *Manager</span><br><span class="line">    sendChan       <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    closeFlag      <span class="keyword">int32</span></span><br><span class="line">    closeChan      <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    closeMutex     sync.Mutex</span><br><span class="line">    closeCallbacks *list.List</span><br><span class="line">    State          <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优雅退出的实现，先通过CAS设置一下closeFlag, 成功设置的gorutine可以执行清理操作，失败的gorutine返回SessionClosedError<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(session *Session)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果成功通过CAS设置了closeFlag</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;session.closeFlag, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        err := session.codec.Close() <span class="comment">// 关闭net.Conn</span></span><br><span class="line">        <span class="built_in">close</span>(session.closeChan) <span class="comment">// 退出sendLoop</span></span><br><span class="line">        <span class="keyword">if</span> session.manager != <span class="literal">nil</span> &#123; <span class="comment">// 从manager中移除session</span></span><br><span class="line">            session.manager.delSession(session)</span><br><span class="line">        &#125;</span><br><span class="line">        session.invokeCloseCallbacks() <span class="comment">// 执行callback</span></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SessionClosedError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发送数据部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func (session *Session) sendLoop() &#123;</span><br><span class="line">    defer session.Close()</span><br><span class="line">    for &#123;</span><br><span class="line">        // 使用select语句来保证，关闭closeChan之后可以退出sendLoop</span><br><span class="line">        select &#123;</span><br><span class="line">        case msg := &lt;-session.sendChan:</span><br><span class="line">            if session.codec.Send(msg) != nil &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">        case &lt;-session.closeChan:</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (session *Session) Send(msg interface&#123;&#125;) (err error) &#123;</span><br><span class="line">    // 在每次Send的时候，都会检查closeFlag，实现快速的退出</span><br><span class="line">    if session.IsClosed() &#123;</span><br><span class="line">        return SessionClosedError</span><br><span class="line">    &#125;</span><br><span class="line">    if session.sendChan == nil &#123;</span><br><span class="line">        return session.codec.Send(msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // send block, 返回一个异常, 有点粗暴了</span><br><span class="line">    select &#123;</span><br><span class="line">    case session.sendChan &lt;- msg:</span><br><span class="line">        return nil</span><br><span class="line">    default:</span><br><span class="line">        return SessionBlockedError</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>其实本意是想找找有没有关于心跳和连接保持方面的代码，但没有什么收获.不过也看到了很多高质量的实现，例如<strong>idgen</strong>，粗粗瞟了一眼就发现，应该是使用了雪花算法，此外还有大量微服务的设计，以及一些我很感兴趣的流行开源技术栈(k8s docker etcd hbase kafka)可以看出是一整套经过深思熟虑的系统，决定过年期间要好好看一看这个库，吸收一下营养。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/造轮子/">造轮子</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/02/05/FishChatServer源码探究/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/05/golang-tcp拆包的正确姿势/"><span>golang tcp拆包的正确姿势</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/05/golang-tcp拆包的正确姿势/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-05T03:07:59.000Z">
          2018-02-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>最近在造一个叫im-go的服务，看名字也能猜出来，是一个基于Go的IM服务，因为不想引入任何的依赖库，所以是手写每个模块的。</p>
<p>之前看过Netty，于是也想做一个类似Netty Codec的，用于编码解码的模块, 方便地处理TCP粘包这种细节问题。</p>
<p>在网上做了一番搜索之后，发现排名靠前的实现，要么出乎意料地复杂，要么根本就是完全错误的，例如</p>
<p>出乎意料的复杂：</p>
<ul>
<li><a href="http://xiaorui.cc/2016/03/08/%E8%A7%A3%E5%86%B3golang%E5%BC%80%E5%8F%91socket%E6%9C%8D%E5%8A%A1%E6%97%B6%E7%B2%98%E5%8C%85%E5%8D%8A%E5%8C%85bug" target="_blank" rel="noopener">解决golang开发socket服务时粘包半包bug</a></li>
<li><a href="golang中tcp socket粘包问题和处理">http://www.01happy.com/golang-tcp-socket-adhere/</a></li>
</ul>
<p>错误的：</p>
<ul>
<li><a href="服务器的粘包处理">https://victoriest.gitbooks.io/golang-tcp-server/content/chapter4.html</a></li>
</ul>
<p>分析一下这个错误的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(reader *bufio.Reader)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    lengthByte, _ := reader.Peek(<span class="number">4</span>)</span><br><span class="line">    lengthBuff := bytes.NewBuffer(lengthByte)</span><br><span class="line">    <span class="keyword">var</span> length <span class="keyword">int32</span></span><br><span class="line">    err := binary.Read(lengthBuff, binary.LittleEndian, &amp;length)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">int32</span>(reader.Buffered()) &lt; length+<span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设执行到了这里，那么已经成功读取了长度到length这个变量中</span></span><br><span class="line">    pack := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="keyword">int</span>(<span class="number">4</span>+length))</span><br><span class="line">    _, err = reader.Read(pack) <span class="comment">//这里是不能保证就能完读到length长度的数据的!!</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(pack[<span class="number">4</span>:]), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我也受了它的误导，基于<a href="https://golang.org/pkg/bufio/#Reader.Peek" target="_blank" rel="noopener">Peek()</a>做了一个非常复杂的实现</p>
<h3 id="正确的姿势"><a href="#正确的姿势" class="headerlink" title="正确的姿势"></a>正确的姿势</h3><p>在翻了翻io和bufio这两个包之后，我找到了<a href="https://golang.org/pkg/io/#ReadFull" target="_blank" rel="noopener">ReadFull</a></p>
<p>ReadFull，就是调用了ReadAtLeast</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ReadAtLeast(r, buf, <span class="built_in">len</span>(buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAtLeast</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>, min <span class="keyword">int</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(buf) &lt; min &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, ErrShortBuffer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> n &lt; min &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> nn <span class="keyword">int</span></span><br><span class="line">        nn, err = r.Read(buf[n:])</span><br><span class="line">        n += nn</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n &gt;= min &#123;</span><br><span class="line">        err = <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; err == EOF &#123;</span><br><span class="line">        err = ErrUnexpectedEOF</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准库里的ReadAtLeast就非常优雅了，用n记录读取的总字节数，nn是每次读取到的字节数，一看就明白。</p>
<p>基于ReadFull的拆包代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *LenthCodec)</span> <span class="title">Decode</span><span class="params">(conn net.Conn)</span> <span class="params">(bodyBuf []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">    lengthBuf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">    _, err = io.ReadFull(conn, lengthBuf)</span><br><span class="line">    <span class="comment">//check error</span></span><br><span class="line">    length := binary.LittleEndian.Uint32(lengthBuf)</span><br><span class="line">    </span><br><span class="line">    bodyBuf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, length)</span><br><span class="line">    _, err = io.ReadFull(conn, bodyBuf)</span><br><span class="line">    <span class="comment">//check error</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a><a href="/tags/造轮子/">造轮子</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/02/05/golang-tcp拆包的正确姿势/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/01/05/后端的一些经验与心得/"><span>后端一年(经验与心得)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/01/05/后端的一些经验与心得/" rel="bookmark">
        <time class="entry-date published" datetime="2018-01-05T01:54:10.000Z">
          2018-01-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>先简单介绍一下我的经历，最早在学校的时候，是在社团里写php和Java，创业时期写js，oc和Ruby，现在是全职用Rails写后端了。</p>
<h4 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h4><p>我们的主要业务有两块，社区和电商</p>
<p>整体业务的峰值qps大概在3000，也算是pv过10亿的站点了，后端team有4个人，除了一个八年老司机，其他人参加工作的年限都不是太久。</p>
<p>我们面对的是一个巨大的基于Rails的历史遗留系统，最早的开发成员均已离开，导致我们常常面对遗留代码一脸蒙逼，到处是没有人知道的逻辑，丑陋的实现，以及很多性能跟不上的接口。</p>
<h4 id="与巨石应用的斗争"><a href="#与巨石应用的斗争" class="headerlink" title="与巨石应用的斗争"></a>与巨石应用的斗争</h4><p>日常工作的重中之重，就是与这个monolith的战斗！</p>
<p><strong>性能篇</strong></p>
<p>以往每年我们搞活动，服务器都会挂，经济损失不少，所以优化性能，保证活动期间的访问是第一要务。</p>
<p>原来的活动整体设计还是比较科学的，活动页面本身是静态化的，主要瓶颈是商品详情页面。</p>
<p>我们利用redis做了三层cache，解决了这个问题。第一层是数据库的缓存，直接把商品信息缓存到redis里，避免了频繁的数据库访问，第二层是单条数据的渲染缓存，可以理解成一小段html，第三层是整个数据集的渲染缓存。</p>
<p>第二个瓶颈出现在一些静态资源上，全面迁移到云存储解决。做完这两件事之后，上上次活动是我们有史以来第一次，没有挂。</p>
<p>就在我们觉得，优化做的不错的时候，上次活动却又挂了。</p>
<p>要知道我们特意买了新服务器，美滋滋觉得这下稳了，没想到…</p>
<p>上次活动挂的原因有以下几点</p>
<ol>
<li>redis hmget，我们通过gem提供的API，缓存了一个巨大的省市区列表，但是没有注意到缓存是分离的，获取整个列表，其实就是一条hmget获取所有独立的缓存片段，这个操作block了redis，导致访问极度缓慢。我们紧急把整个列表转成json，直接贴到代码里返回hotfix了这个问题</li>
<li>突然无法通过redis sential进行连接，这套sential系统是由已经离职的运维搭建的，我们绕开sential直接连接redis，解决了这个问题</li>
<li>fd limit,发现依然是1024，修改后却依然时常502，发现运维修改的是root用户的fd数量…坑爹！</li>
<li>在支付回调中有一段用于统计的sql，订单量大了以后slow query，block了数据库，我们直接注释了这段可有可无的老代码，解决。</li>
</ol>
<p>总结一下，对于web应用的场景来说，大都是读多写少，缓存读请求，异步写请求，是我们经常采用的两种效果不错的方式。在数据库层面，对于遗留代码中效率低下的查询进行重写，重点改写了所有N＋1查询，对一些逐条插入的语句用batch insert合并写入操作，也有不错的提升。</p>
<p><strong>替换篇</strong></p>
<p>做的比较有意思的事，是写了我们内部用的个推GEM。原来使用的是github上开源的一个GEM，但是已经很久没更新了，无法适应我们的使用需求。我基于个推最新的HTTPS的API，写了一个Ruby的包装。</p>
<p>这里要吐槽的是个推的技术水平。推送服务是做的不错，但API怎么做的这么low。他们定义了一个叫authorize的http header用来传递身份信息…违背了RFC关于HTTP头必须大写开头的规范。一些语言的标准库(Go、Ruby…)会自动帮你把authorize转化成Authorize，导致个推那边一直返回auth error…而个推的接口又是HTTPS的，抓包调试很困难，浪费了我很长时间调试这个问题。</p>
<p><strong>重构篇</strong><br>重构的主要方针就是拆分，尽可能把功能从巨石应用中拆出去。如果一时半会难以拆分的，代码上也尽可能让逻辑高度内聚，方便以后迁移。</p>
<p>消息系统的重构<br>消息系统是一个，出点问题没什么，但做得好会非常出彩的功能。我一直觉得，像知乎这种社区的成功，除了内容，很大一部分要归功于消息的体验。目前，我们几乎所有页面，都会展示新消息的数量，导致每次请求都会去主数据库的消息表做count，计算各种消息的数量返回给前端。我正在着手把整个系统迁移到另一个独立的数据库，以后可以作为单独的服务供内部调用，降级限流什么的都很方便。</p>
<p>搜索的重构</p>
<p>原来的搜索是基于Solr的java工程，是一个我们内部没人维护好多年的烂摊子，虽然各方面表现都不错。我们使用了用Elasticsearch替换掉了。</p>
<p><strong>新系统</strong><br>我新写了内部的财务系统，过程中遇到很多问题，写的也很痛苦，但最终效果还是不错。因为原来的各种报表都是直接基于生产数据库的，对业务会有冲击，新系统写了一个同步模块，可以增量同步订单数据到财务系统的专用数据库，这样就不会对业务带来影响。</p>
<p>遇到的比较大的坑就是内存爆炸。有一些耗时计算我放到了消息对列里，整个worker进程的内存占用疯狂上升。最终发现是Ruby内存模型的特点，分配大量对象，却不进行回收。需要你使用batch处理的方式，切成一小块一小块的数据，一次处理一小块，这样下次计算的时候就可以重用之前申请的那些对象。</p>
<p>另外也通过时间换空间的方式，把加载全部数据做计算，改成了加载部分数据做计算，然后汇总结果这样的方式，极大降低了内存占用，并每天重启worker进程，解决了最主要的内存问题(1G内存的机器…)。</p>
<p>这个项目让我真实感觉到，有些场景真的不是Ruby擅长的领域。Ruby的内存模型，就是尽量分配对象，从不真正回收，只会重用。Ruby VM启动就有大量空对象等着被分配，假如我加载了很多数据，空对象不够用了，VM就向操作系统申请一批内存，用完后也不释放，等着下次重用。而报表计算的最佳场景就是能加载大量数据，算一下结果，算完释放掉内存。</p>
<p><strong>监控</strong><br>可以看我之前的文章<a href="http://www.jianshu.com/p/69ce51cfcb3d" target="_blank" rel="noopener">使用ELK构建分布式日志分析系统</a></p>
<p><strong>代码篇</strong><br>在日常编码、重构的过程中，经常使用的技术是</p>
<ol>
<li>设计模式</li>
<li>元编程</li>
<li>自动化测试</li>
</ol>
<p>运用设计模式，写出符合OOP规范的代码。分割每个类的职责，尽量让各个功能的逻辑内聚，只提供彼此间调用的接口，这是我最近才刚领悟的代码整洁之道。</p>
<p>元编程抽象代码，我很早就在使用的奇技淫巧。现在却用的越来越少了，因为它违背了OOP，可维护性比较差，对使用者的水平有很大要求，也容易<strong>坑队友</strong>。</p>
<p>简单地说，我代码中的if/else越来越少了，类越来越多了，改动起来越来方便了，改动影响的部分越来少了，美滋滋。</p>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>用一句古老的名言，软件开发没有银弹。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/后端/">后端</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/01/05/后端的一些经验与心得/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/10/05/使用ELK构建分布式日志分析系统/"><span>使用ELK构建分布式日志分析系统</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/10/05/使用ELK构建分布式日志分析系统/" rel="bookmark">
        <time class="entry-date published" datetime="2017-10-05T01:51:39.000Z">
          2017-10-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="https://juejin.im/entry/596f38526fb9a06bbb32e759/detail" target="_blank" rel="noopener"><img src="https://badge.juejin.im/entry/596f38526fb9a06bbb32e759/likes.svg?style=plastic" alt=""></a></p>
<p>分布式系统的日志散落在各个服务器上，对于监控和排错非常不利，我们基于ELK构建了整套日志收集，分析，展示系统。</p>
<h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="http://upload-images.jianshu.io/upload_images/4073552-2ea1c542bb9d7c12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h3><h4 id="1-整理Rails日志"><a href="#1-整理Rails日志" class="headerlink" title="1.整理Rails日志"></a>1.整理Rails日志</h4><p>我们最关心的是Rails的访问日志，但是Rails日志本身的格式是有问题的，举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Started GET &quot;/&quot; for 10.1.1.11 at 2017-07-19 17:21:43 +0800</span><br><span class="line">Cannot render console from 10.1.1.11! Allowed networks: 127.0.0.1, ::1, 127.0.0.0/127.255.255.255</span><br><span class="line">Processing by Rails::WelcomeController#index as HTML</span><br><span class="line">  Rendering /home/vagrant/.rvm/gems/ruby-2.4.0@community-2.4/gems/railties-5.1.2/lib/rails/templates/rails/welcome/index.html.erb</span><br><span class="line">  Rendered /home/vagrant/.rvm/gems/ruby-2.4.0@community-2.4/gems/railties-5.1.2/lib/rails/templates/rails/welcome/index.html.erb (2.5ms) Completed 200 OK in 184ms (Views: 10.9ms)</span><br></pre></td></tr></table></figure>
<p>可以看到，一次请求的日志散落在多行中，而且在并发情况下，不同请求的日志会交织在一起，针对这个问题，我们使用<a href="https://github.com/shadabahmed/logstasher" target="_blank" rel="noopener">logstasher</a>重新生成一份JSON格式的日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;identifier&quot;:&quot;/home/vagrant/.rvm/gems/ruby-2.4.0@community-2.4/gems/railties-5.1.2/lib/rails/templates/rails/welcome/index.html.erb&quot;,&quot;layout&quot;:null,&quot;name&quot;:&quot;render_template.action_view&quot;,&quot;transaction_id&quot;:&quot;35c707dd9d4cd1a79f37&quot;,&quot;duration&quot;:2.34,&quot;request_id&quot;:&quot;bc291df8-8681-47d3-8e10-bd5d93a021a0&quot;,&quot;source&quot;:&quot;unknown&quot;,&quot;tags&quot;:[],&quot;@timestamp&quot;:&quot;2017-07-19T09:29:05.969Z&quot;,&quot;@version&quot;:&quot;1&quot;&#125;</span><br><span class="line">&#123;&quot;method&quot;:&quot;GET&quot;,&quot;path&quot;:&quot;/&quot;,&quot;format&quot;:&quot;html&quot;,&quot;controller&quot;:&quot;rails/welcome&quot;,&quot;action&quot;:&quot;index&quot;,&quot;status&quot;:200,&quot;duration&quot;:146.71,&quot;view&quot;:5.5,&quot;ip&quot;:&quot;10.1.1.11&quot;,&quot;route&quot;:&quot;rails/welcome#index&quot;,&quot;request_id&quot;:&quot;bc291df8-8681-47d3-8e10-bd5d93a021a0&quot;,&quot;source&quot;:&quot;unknown&quot;,&quot;tags&quot;:[&quot;request&quot;],&quot;@timestamp&quot;:&quot;2017-07-19T09:29:05.970Z&quot;,&quot;@version&quot;:&quot;1&quot;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-使用Logstash收集日志"><a href="#2-使用Logstash收集日志" class="headerlink" title="2.使用Logstash收集日志"></a>2.使用Logstash收集日志</h4><p>Logstash通过一份配置文件描述了数据从哪里来，经过怎样的处理流程，输出到何处这整套流程，分别对应于input,filter,output三个概念。</p>
<p>我们先使用简单的配置来验证一下正确性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; &quot;/home/vagrant/blog/log/logstash_development.log&quot;</span><br><span class="line">      start_position =&gt; beginning</span><br><span class="line">      ignore_older =&gt; 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">        stdout &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这份配置中，我们从上一步生成的日志文件中读取，并输出到stdout中，结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2017-07-19T09:59:01.520Z precise64 &#123;&quot;method&quot;:&quot;GET&quot;,&quot;path&quot;:&quot;/&quot;,&quot;format&quot;:&quot;html&quot;,&quot;controller&quot;:&quot;rails/welcome&quot;,&quot;action&quot;:&quot;index&quot;,&quot;status&quot;:200,&quot;duration&quot;:4.85,&quot;view&quot;:3.28,&quot;ip&quot;:&quot;10.1.1.11&quot;,&quot;route&quot;:&quot;rails/welcome#index&quot;,&quot;request_id&quot;:&quot;27b8e5a5-dd1d-4957-9c91-435347d50888&quot;,&quot;source&quot;:&quot;unknown&quot;,&quot;tags&quot;:[&quot;request&quot;],&quot;@timestamp&quot;:&quot;2017-07-19T09:59:01.030Z&quot;,&quot;@version&quot;:&quot;1&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>然后，修改Logstash的配置文件，将output改为Elasticsearch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; &quot;/vagrant/blog/log/logstash_development.log&quot;</span><br><span class="line">      start_position =&gt; beginning</span><br><span class="line">      ignore_older =&gt; 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [ &quot;localhost:9200&quot; ]</span><br><span class="line">    user =&gt; &apos;xxx&apos;</span><br><span class="line">    password =&gt; &apos;xxx&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，整个配置文件的可读性是非常高的，input中描述了输入源是我们整理好的日志文件，输出到Elasticsearch中。</p>
<p>然后就可以使用Kibanana来进行日志分析的工作了。</p>
<h4 id="3-Kibana的一些实践"><a href="#3-Kibana的一些实践" class="headerlink" title="3. Kibana的一些实践"></a>3. Kibana的一些实践</h4><p>基于Kibana，我们可以定制Elasticsearch的搜索，来查询一些非常有价值的数据</p>
<ul>
<li>查询某个接口的请求情况</li>
<li>查询耗时在500ms以上的超慢接口</li>
<li>查询线上报500的接口</li>
<li>统计高频接口<br>……</li>
</ul>
<h4 id="4-Future"><a href="#4-Future" class="headerlink" title="4.Future"></a>4.Future</h4><p>有了ELK提供的数据，我们已经可以比较方便的完成分布式情况下的错误排查，高频接口统计，为下一步的优化提供了指导。我们不必再根据业务逻辑去猜测哪些才是20%的热点，而是有了实实在在的数据支撑。</p>
<h4 id="5-问题"><a href="#5-问题" class="headerlink" title="5. 问题"></a>5. 问题</h4><p>当然，在使用过程中也遇到过一些问题。在活动期间，访问量暴增的情况下，Elasticsearch吃了很多内存，直接拖垮了两台机器。我们通过临时关闭几台web server上的logstash暂时解决了这个问题。后续还需要对JVM进行一些调优。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/后端/">后端</a><a href="/tags/ELK/">ELK</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/10/05/使用ELK构建分布式日志分析系统/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/09/05/自制简易前端MVC框架/"><span>自制简易前端MVC框架</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/09/05/自制简易前端MVC框架/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-05T01:35:28.000Z">
          2017-09-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>周末花了大概7小时写了一个简易的响应式blog，原意是练习css的，写着写着却去实现了一套前端路由并渲染的东西，这里写一点心得体会</p>
<h4 id="基本思路与涉及技术"><a href="#基本思路与涉及技术" class="headerlink" title="基本思路与涉及技术"></a>基本思路与涉及技术</h4><ol>
<li>使用url hash进行路由跳转</li>
<li>js监听hashchange事件，根据当前hash去决定界面如何渲染</li>
<li>调用 addHandler(hash, func) 这个api来映射hash与handler</li>
<li>gulp，scss， es6，模板引擎</li>
<li>需要一些es6的知识，需要理解this</li>
<li>整个工程在 <a href="https://github.com/MoonShining/front-end-hero/tree/master/blog，" target="_blank" rel="noopener">https://github.com/MoonShining/front-end-hero/tree/master/blog，</a> front-end-hero是我自己写的模板代码生成器，用它来练习CSS， 使用<strong>ruby create.rb -n name -s url</strong>来快速创建目录结构，免去重复的工作</li>
</ol>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="http://upload-images.jianshu.io/upload_images/4073552-dabf8b4dce1f48e9.gif?imageMogr2/auto-orient/strip" alt="web.gif"></p>
<h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> blog = <span class="keyword">new</span> Blog()</span><br><span class="line">    <span class="comment">// add simple router</span></span><br><span class="line">    blog.addHandler([<span class="string">''</span>, <span class="string">'#programming'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> data = &#123;<span class="attr">articles</span>: [&#123;<span class="attr">title</span>: <span class="string">'stories to be continue'</span>, <span class="attr">date</span>: <span class="string">'2017-04-09'</span>&#125;]&#125;</span><br><span class="line">        <span class="keyword">this</span>.compile(<span class="string">'#article-template'</span>, data) </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    blog.addHandler(<span class="string">'#about'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> data = &#123;<span class="attr">avatar</span>: <span class="string">'http://7xqlni.com1.z0.glb.clouddn.com/IMG_0337.JPG?imageView2/1/w/100/h/100'</span>, <span class="attr">name</span>: <span class="string">'Jack Zhou'</span>&#125;</span><br><span class="line">        <span class="keyword">this</span>.compile(<span class="string">'#about-template'</span>, data)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize the page</span></span><br><span class="line">    blog.init()</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>调用blog.addHandler来自定义路由改变之后触发的动作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = <span class="string">'#content'</span></span><br><span class="line">        <span class="keyword">this</span>.router = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init()&#123;</span><br><span class="line">        <span class="keyword">this</span>.dispatch()</span><br><span class="line">        $(<span class="built_in">window</span>).on(<span class="string">'hashchange'</span>,()=&gt;&#123; </span><br><span class="line">            <span class="keyword">this</span>.dispatch()</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch()&#123;</span><br><span class="line">        <span class="keyword">this</span>.handle(<span class="built_in">window</span>.location.hash)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addHandler(hash, func)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(hash))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> hash)&#123;</span><br><span class="line">                <span class="keyword">this</span>.router[item] = func</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.router[hash] = func</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle(hash)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.routeMissing(hash))&#123;</span><br><span class="line">            <span class="keyword">this</span>.handle404()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.router[hash].call(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    routeMissing(hash)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.router[hash])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle404()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'handler not found for this hash'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compile(templateSelector, data, element=<span class="keyword">this</span>.content)&#123;</span><br><span class="line">        <span class="keyword">let</span> source   = $(templateSelector).html()</span><br><span class="line">        <span class="keyword">let</span> template = Handlebars.compile(source)</span><br><span class="line">        $(element).html(template(data))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>this.router</code>是个是核心，其实也参考了一点Rails的设计，通过一个对象去保存 路由＝》动作 的关系， 并且把核心逻辑都封装在Blog这个类中。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/前端/">前端</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/09/05/自制简易前端MVC框架/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/06/05/关于Netty的一些理解、实践与陷阱/"><span>关于Netty的一些理解、实践与陷阱</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/06/05/关于Netty的一些理解、实践与陷阱/" rel="bookmark">
        <time class="entry-date published" datetime="2017-06-05T01:49:00.000Z">
          2017-06-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="核心概念的理解"><a href="#核心概念的理解" class="headerlink" title="核心概念的理解"></a>核心概念的理解</h3><p>Netty对于网络层进行了自己的抽象，用Channel表示连接，读写就是Channel上发生的事件，ChannelHandler用来处理这些事件，ChannelPipeline基于unix哲学提供了一种优雅的组织ChannelHandler的方式，用管道解耦不同层面的处理。现在回过头来看看，真的是非常天才和优雅的设计，是我心中API设计的典范之一了。</p>
<h3 id="TCP半包、粘包"><a href="#TCP半包、粘包" class="headerlink" title="TCP半包、粘包"></a>TCP半包、粘包</h3><p>使用Netty内置的<strong>LineBasedFrameDecoder</strong>或者<strong>LengthFieldBasedFrameDecoder </strong>,我们只要在pipeline中添加，就解决了这个问题。</p>
<h3 id="Writtable问题"><a href="#Writtable问题" class="headerlink" title="Writtable问题"></a>Writtable问题</h3><p>有时候，由于TCP的send buffer满了，向channel的写入会失败。我们需要检查<strong>channel().isWritable()</strong>标记来确定是否执行写入。</p>
<h3 id="处理耗时任务"><a href="#处理耗时任务" class="headerlink" title="处理耗时任务"></a>处理耗时任务</h3><p>Netty In Action以及网上的一些资料中，都没有很直接的展示如何在Netty中去处理耗时任务。其实也很简单，只要给handler指定一个事件循环就可以，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventExecutorGroup longTaskGroup = <span class="keyword">new</span> DefaultEventExecutorGroup(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = channel.pipeline();</span><br><span class="line">        ...</span><br><span class="line">        pipeline.addLast(longTaskGroup, <span class="keyword">new</span> PrintHandler());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Pitfall"><a href="#Pitfall" class="headerlink" title="Pitfall"></a>Pitfall</h3><p>Netty的ChannelPipeline只有一条双向链，消息入站，经过一串InBoundHandler之后，以相反的顺序再经过OutBoundHandler出站.因此，我们自定义的handler一般会处于pipeline的<strong>末尾</strong>!</p>
<p>举个例子，当以如下顺序添加handler时，如果调用ChannelHandlerContext上的writeAndFlush方法，出站消息是无法经过StringEncoder的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventExecutorGroup longTaskGroup = <span class="keyword">new</span> DefaultEventExecutorGroup(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = channel.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LineBasedFrameDecoder(<span class="number">64</span> * <span class="number">1024</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8))；</span><br><span class="line">        pipeline.addLast(longTaskGroup, <span class="keyword">new</span> PrintHandler());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个问题有两个解决方式</p>
<ol>
<li>调整handler的顺序</li>
<li>调用channel上的writeAndFlush方法，强制使消息在整个pipeline上流动</li>
</ol>
<p>调整handler的顺序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventExecutorGroup longTaskGroup = <span class="keyword">new</span> DefaultEventExecutorGroup(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = channel.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LineBasedFrameDecoder(<span class="number">64</span> * <span class="number">1024</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(longTaskGroup, <span class="keyword">new</span> PrintHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用Channel上的writeAndFlush方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        ctx.writeAndFlush(msg);</span></span><br><span class="line">        ctx.channel().writeAndFlush(msg);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.voidcn.com/article/p-yhpuvvkx-mm.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-yhpuvvkx-mm.html</a><br><a href="https://stackoverflow.com/questions/37474482/dealing-with-long-time-task-such-as-sql-query-in-netty" target="_blank" rel="noopener">https://stackoverflow.com/questions/37474482/dealing-with-long-time-task-such-as-sql-query-in-netty</a><br>《Netty In Action》</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/后端/">后端</a><a href="/tags/异步IO/">异步IO</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/06/05/关于Netty的一些理解、实践与陷阱/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
  </p>
</footer>
    
  </div>
</div>
</body>
</html>